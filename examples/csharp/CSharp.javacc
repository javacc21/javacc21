PARSER_PACKAGE="org.parsers.csharp";
NODE_PACKAGE="org.parsers.csharp.tree";
DEFAULT_LEXICAL_STATE=CSHARP;
PRESERVE_TABS;
TABS_TO_SPACES=4;
ENSURE_FINAL_EOL;

DEACTIVATE_TOKENS=ADD,ASSEMBLY,ASYNC,AWAIT,INTO,MODULE, NAMEOF,
                  PARTIAL, RECORD, REMOVE,VAR,WHEN,YIELD, ARGLIST,
                  GET,SET,INIT,WITH,
                  // The following are used in patterns:
                  AND, OR, NOT,
                  // The following are all used in queries
                  ASCENDING,BY,DESCENDING,EQUALS,FROM,GROUP,JOIN,LET,
                  INTO, ON, ORDERBY,SELECT,WHERE;

INCLUDE "CSharpLexer.javacc"

// Just an experiment to see if this makes any difference!
INJECT ParseException : extends RuntimeException

/*
 * This is not used

INJECT PARSER_CLASS :
{
   public PARSER_CLASS(Path path, java.util.Set<String> ppSymbols) throws IOException {
      this(path);
      if (ppSymbols != null) token_source.addSymbols(ppSymbols);
   }
}
 */

#CompilationUnit# :
   (ExternAliasDirective)*
   (UsingDirective)*
   (GlobalAttributeSection)*
   CompilationUnitBody
   <EOF>
   {return CURRENT_NODE;}
;

CompilationUnitBody#void :
    FileScopedNamespaceDeclaration // Since 10.0
    |
    (
      SCAN ~(<EOF>|"namespace"|TypeDeclarationLA)
      =>
      Statement
    )*
    (NamespaceDeclaration | TypeDeclaration)*
;

TypeDeclarationLA#scan :
  (AttributeSection)*
  Modifiers
  [SCAN {checkNextTokenImage("partial")}# => ACTIVATE_TOKENS PARTIAL ("partial")]
  ASSERT ~("delegate" "*")
  ("struct"|"class"|"interface"|"enum"|"delegate"
    |SCAN {checkNextTokenImage("record")}=>{})
;

FileScopedNamespaceDeclaration :
   "namespace" QualifiedIdentifier ";" =>||
   (ExternAliasDirective)*
   (UsingDirective)*
   (TypeDeclaration)*
;

NamespaceDeclaration :
   "namespace"  QualifiedIdentifier  =>|+1
   NamespaceBody [";"]
;

QualifiedIdentifier :
    <IDENTIFIER> ("." <IDENTIFIER>)*
;

NamespaceBody :
   "{"
       (ExternAliasDirective)*
       (UsingDirective)*
       (
          NamespaceDeclaration
          |
          TypeDeclaration
       )*
   "}"
;

ExternAliasDirective :
   "extern"
   <IDENTIFIER>
   ASSERT {getToken(0).getImage().equals("alias")}#
   =>||
   <IDENTIFIER> ";"
;

UsingDirective :
    UsingStaticDirective
    |
    UsingAliasDirective
    |
    UsingNamespaceDirective
;

UsingStaticDirective :
    "using" "static" =>|| Name ";"
;

UsingAliasDirective :
   "using" <IDENTIFIER> "=" =>|| Name ";"
;

UsingNamespaceDirective :
    "using" Name ";" =>||
;

GlobalAttributeSection :
   "["  ACTIVATE_TOKENS ASSEMBLY, MODULE ("assembly" | "module") =>|| ":" AttributeList [","] "]"
;

AttributeSection :
   "["
   [
      => (<EVENT> |<RETURN> |<IDENTIFIER> ) ":"
   ]
   AttributeList
   [","]
   "]"
;

AttributeList :
     Attribute ("," =>|+1 Attribute)*
;

Attribute :
   Name
   [AttributeArguments]
;

AttributeArguments :
    "("
    [
       SCAN ~(")" | <IDENTIFIER>"=")
       => [=>Type ":" ] Expression
       (
          ","
          [=>Type ":"] // since when?
          Expression
       )*
    ]
    [
       <IDENTIFIER> "=" =>|| Expression #NamedArgument(3)
       (
          "," <IDENTIFIER> "=" Expression #NamedArgument(3)
       )*
    ]
    ")"
;

NamedArgument :
    <IDENTIFIER> "=" Expression
;

/** Name of a Type or a Namespace */
Name :
   (
     QualifiedAliasMember
     |
     <IDENTIFIER>[TypeArgumentList]
   )
   (
      SCAN 2
      "." <IDENTIFIER> [TypeArgumentList]
   )*
;

QualifiedAliasMember :
   <IDENTIFIER> "::" =>|| <IDENTIFIER>
   [TypeArgumentList]
;

TypeArgumentList :
   "<"
   [
      (AttributeSection)*
      ("void" | Type)
      ("," (AttributeSection)* ("void" | Type))*
   ]
   DEACTIVATE_TOKENS RIGHT_SHIFT, RIGHT_SHIFT_ASSIGN
   (">")
;


TypeDeclaration :
  SCAN 0 {!checkNextTokenType(TokenType.RBRACE) && !checkNextTokenType(TokenType.EOF)}# =>
  (
   ClassDeclaration
   |
   StructDeclaration
   |
   RecordDeclaration
   |
   InterfaceDeclaration
   |
   EnumDeclaration
   |
   DelegateDeclaration
  )
;

INJECT PARSER_CLASS :
{
   EnumSet<TokenType> permissibleModifiers;
}

Modifiers#void : //TODO
  (
    SCAN { permissibleModifiers == null
         ||
         permissibleModifiers.contains(getToken(1).getType()) }#
      =>
      ("new"|"public"|"protected"|"internal"|"private"|"abstract"
      |"sealed"|"static"|"unsafe"|"override"|"virtual"|"extern"
      // This is allowed on methods in some cases,
      // but not sure where exactly or when this was added
      // Have to check where this is possible and since when
      | "readonly"
      // Note that "ref" is only a permissible keyword for struct
      // since 7.3
      | "ref"
      | "volatile"
      )
      {
         if (permissibleModifiers != null) {
            permissibleModifiers.remove(getToken(0).getType());
         }
      }
     |
     SCAN { permissibleModifiers == null
            || permissibleModifiers.contains(TokenType.ASYNC) && checkNextTokenImage("async")
            || permissibleModifiers.contains(TokenType.RECORD) && checkNextTokenImage("record")
          }#
      => ACTIVATE_TOKENS ASYNC, RECORD ("async")
      { if (permissibleModifiers!=null) permissibleModifiers.remove(TokenType.ASYNC);}
  )*
  {permissibleModifiers = null;}#
;

ClassDeclaration :
  {
    boolean isaRecordClass = false;
    permissibleModifiers = EnumSet.of(TokenType.NEW,  TokenType.PUBLIC, TokenType.PROTECTED,
                                      TokenType.INTERNAL, TokenType.PRIVATE, TokenType.ABSTRACT,
                                      TokenType.SEALED, TokenType.STATIC, TokenType.UNSAFE);
  }#
  (AttributeSection)*
  Modifiers
  [SCAN {checkNextTokenImage("partial")}# => ACTIVATE_TOKENS PARTIAL ("partial")]
  [
     // Record classes are since 10.0
     // and barely mentioned anywhere
     SCAN {checkNextTokenImage("record")}#
     => ACTIVATE_TOKENS RECORD ("record")
     {isaRecordClass =true;}
  ]
  "class"
  =>||
   <IDENTIFIER>
   [
      SCAN 1 {isaRecordClass}
      =>
      "(" FormalParameters ")"
   ]
  [TypeParameterList]
  [SCAN 1 {isaRecordClass} => "(" [FormalParameters] ")"]
  [":" (Name[ SCAN 1 {isaRecordClass} => "(" ArgumentList ")"] | "object" | "dynamic" | "string") ("," Name[SCAN 1 {isaRecordClass} => "(" ArgumentList ")"] )*]
  TypeParameterConstraints
   (
      "{" (ClassMemberDeclaration)* "}"
      |
      SCAN {isaRecordClass} => ";"
   )
  [";"]
;

StructDeclaration :
  {
    boolean isaRecordStruct = false;
    permissibleModifiers = EnumSet.of(TokenType.STATIC, TokenType.INTERNAL, TokenType.PUBLIC,
                                      TokenType.PRIVATE, TokenType.PROTECTED, TokenType.REF,
                                      TokenType.READONLY, TokenType.UNSAFE, TokenType.NEW);
  }#
  (AttributeSection)*
  Modifiers
  [SCAN {checkNextTokenImage("partial")}# => ACTIVATE_TOKENS PARTIAL ("partial")]
  [
     // Record structs are since 10.0
     SCAN {checkNextTokenImage("record")}#
     => ACTIVATE_TOKENS RECORD ("record")
     {isaRecordStruct=true;}
  ]
   "struct"
   =>||
   <IDENTIFIER>
   [TypeParameterList]
   [
      SCAN 1 {isaRecordStruct}
      =>
      "(" FormalParameters ")"
   ]
   [":" Name ("," Name)*]
   TypeParameterConstraints
   (
      "{" (ClassMemberDeclaration)* "}"
      |
      SCAN {isaRecordStruct} => ";"
   )
   [";"]
;

RecordDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.STATIC, TokenType.INTERNAL, TokenType.PUBLIC,
                                      TokenType.PRIVATE, TokenType.PROTECTED, TokenType.SEALED,
                                      TokenType.ABSTRACT);
  }#
  (AttributeSection)*
  Modifiers
  [SCAN {checkNextTokenImage("partial")}# => ACTIVATE_TOKENS PARTIAL ("partial")]
  ASSERT {checkNextTokenImage("record")}#
  ACTIVATE_TOKENS RECORD ("record")
  =>||
  <IDENTIFIER>
  [TypeParameterList]
  ["(" [FormalParameters] ")"]
  [
    // Call of base constructor
    // Where is this documented?
    ":" Name ["(" [ArgumentList] ")"]
  ]
  TypeParameterConstraints
  (
    "{" (ClassMemberDeclaration)* "}" [";"]
    |
    ";"
  )
;

InterfaceDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.INTERNAL, TokenType.PUBLIC, TokenType.PARTIAL,
                                      TokenType.PRIVATE);
  }#
  (AttributeSection)*
  Modifiers
  [SCAN {checkNextTokenImage("partial")}# => ACTIVATE_TOKENS PARTIAL ("partial")]
  "interface"
  =>||
  <IDENTIFIER>
  [TypeParameterList]
  [":" Name ("," Name)*]
  TypeParameterConstraints
  "{"
  (InterfaceMemberDeclaration)*
  "}"
  [";"]
;

InterfaceMemberDeclaration :
   SCAN TypeDeclarationLA =>
   TypeDeclaration
   |
   InterfacePropertyDeclaration
   |
   InterfaceMethodDeclaration
   |
   InterfaceEventDeclaration
   |
   InterfaceIndexerDeclaration
;

InterfaceEventDeclaration :
   (AttributeSection)*
   ["new"]
   "event" =>||
   Type
   <IDENTIFIER>
   ";"
;

InterfaceIndexerDeclaration :
   (AttributeSection)*
   ["new"]
   Type
   "this"
   "[" FormalParameters "]"
   "{" (InterfaceAccessor)+ "}"
;

EnumDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.STATIC, TokenType.INTERNAL, TokenType.PUBLIC,
                                      TokenType.PRIVATE, TokenType.PROTECTED, TokenType.SEALED,
                                      TokenType.ABSTRACT, TokenType.PARTIAL, TokenType.UNSAFE);
  }#
  (AttributeSection)*
  Modifiers
  "enum"
  =>||
  <IDENTIFIER>
  [":" ("sbyte"|"byte"|"short"|"ushort"|"int"|"uint"|"long"|"ulong"|"char")]
  EnumBody
  [";"]
;

EnumBody#void :
   "{"
   [
      EnumMemberDeclaration
      ("," =>|+1 EnumMemberDeclaration)*
      [","]
   ]
   "}"
;

EnumMemberDeclaration :
   (AttributeSection)*
   <IDENTIFIER>
   ["=" Expression]
;

DelegateDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.INTERNAL, TokenType.UNSAFE, TokenType.VIRTUAL,
                                      TokenType.OVERRIDE, TokenType.NEW, TokenType.ABSTRACT);
  }#
  (AttributeSection)*
  Modifiers
  "delegate"
  ASSERT ~("*")
  =>||
  ReturnType
  <IDENTIFIER>
  [TypeParameterList]
  "(" [FormalParameters] ")"
  TypeParameterConstraints
  ";"
;

TypeParameterConstraints :
  ACTIVATE_TOKENS WHERE
  (TypeParameterConstraint)*
;

TypeParameterConstraint :
   <WHERE>
   DEACTIVATE_TOKENS WHERE
   (
      <IDENTIFIER>
      ":"
      (
         "new" "(" ")"
         |
         ("struct" | "class" ["?"] | Name ["?"]) (SCAN 2 "," Name["?"])* ["," "new" "(" ")"]
         |
         "default" // Since C# 9.0 apparently
      )
   )
;

ClassMemberDeclaration :
  ConstantDeclaration
  |
  SCAN TypeDeclarationLA =>
  TypeDeclaration
  |
  MethodDeclaration
  |
  FieldDeclaration
  |
  PropertyDeclaration
  |
  EventDeclaration
  |
  IndexerDeclaration
  |
  OperatorDeclaration
  |
  ConstructorDeclaration
  |
  SCAN ~\StructDeclaration
  => DestructorDeclaration
  |
  SCAN \StructDeclaration
  => StructMemberDeclarationUnsafe
  |
  StaticConstructorDeclaration
;

StructMemberDeclarationUnsafe :
  {
    permissibleModifiers = EnumSet.of(TokenType.STATIC, TokenType.INTERNAL, TokenType.PUBLIC,
                                      TokenType.PRIVATE, TokenType.PROTECTED, TokenType.UNSAFE);
  }#
  (AttributeSection)*
  Modifiers
  "fixed"
  =>||
  Type
  (<IDENTIFIER> "[" Expression "]")+
  ";"
;

ConstantDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.INTERNAL);
  }#
  (AttributeSection)*
  Modifiers
  "const"
  =>||
  Type
  ConstantDeclarator ("," ConstantDeclarator)*
  ";"
;

ConstantDeclarator : <IDENTIFIER> "=" Expression ;

FieldDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.STATIC,TokenType.UNSAFE, TokenType.VIRTUAL,
                                      TokenType.OVERRIDE, TokenType.NEW, TokenType.ABSTRACT,
                                      TokenType.EXTERN, TokenType.ASYNC, TokenType.INTERNAL,
                                      TokenType.REF, TokenType.READONLY, TokenType.SEALED,
                                      TokenType.VOLATILE);
  }#
  (AttributeSection)*
  Modifiers
  Type
  =>|+2
  VariableDeclarator ("," VariableDeclarator)*
 ";"
;

PropertyDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.STATIC, TokenType.UNSAFE, TokenType.VIRTUAL,
                                      TokenType.OVERRIDE, TokenType.NEW, TokenType.ABSTRACT,
                                      TokenType.EXTERN, TokenType.ASYNC, TokenType.INTERNAL,
                                      TokenType.REF, TokenType.READONLY, TokenType.SEALED,
                                      TokenType.VOLATILE);
  }#
  (AttributeSection)*
  Modifiers
  Type
  Name
  =>|+1
  PropertyBody
;

InterfacePropertyDeclaration :
   (AttributeSection)*
   ("new" | "public")* // FIXME!
   Type
   <IDENTIFIER> =>|+1
   (
      "{" (InterfaceAccessor)+ "}"
      |
      // This seems to be another of these
      // new features not hardly documented
      // anywhere. For read-only 'get' properties,
      // apparently, you can dispense with the
      // "{ get }" but I'm not sure if this is only
      // in interfaces.
      "=>" Expression ";"
   )
;

InterfaceAccessor : // TODO, check that there is only one of each
    (AttributeSection)*
    ASSERT {checkNextTokenImage("get")||checkNextTokenImage("set")||checkNextTokenImage("init")}#
    : "Expecting get, set, or init here"
    ACTIVATE_TOKENS GET,SET,INIT
    ( "get" | "set" | "init" )
    =>||
    ["=>" Expression ]
    ";"
;


EventDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.STATIC, TokenType.VIRTUAL,
                                      TokenType.OVERRIDE, TokenType.NEW, TokenType.ABSTRACT,
                                      TokenType.INTERNAL, TokenType.SEALED);
  }#
   (AttributeSection)*
   Modifiers
   "event"
   =>||
   Type
   (
      VariableDeclarator =>|+1 ("," VariableDeclarator)* ";"
      |
      Name
      "{"
      (
          AddAccessorDeclaration RemoveAccessorDeclaration
          |
          RemoveAccessorDeclaration AddAccessorDeclaration
      )
      "}"
   )
;

IndexerDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.STATIC, TokenType.VIRTUAL,
                                      TokenType.OVERRIDE, TokenType.NEW, TokenType.ABSTRACT,
                                      TokenType.INTERNAL, TokenType.SEALED);
  }#
  (AttributeSection)*
  Modifiers
  Type
  [Name "."]
  "this"
  "["
  =>||
   FormalParameters
  "]"
  (
     "{" (AccessorDeclaration)+ "}"
     |
     "=>" ["ref"] Expression ";"
  )
;

OperatorDeclaration :
   (AttributeSection)*
   ( "public" | "static" | "extern" | "unsafe")+
   (Type | "implicit" | "explicit")
   "operator" =>||
   (
      ("+"|"-") "(" ["in"] Type <IDENTIFIER> ["," ["in"] Type <IDENTIFIER>] ")"
      |
      ("!"|"~"|"++"|"--"|"true"|"false") "(" ["in"] Type <IDENTIFIER> ")"
      |
      ("*"|"/"|"%"|"&"|"|"|"^"|"<<"|">>"|"=="|"!="|">"|"<"|">="|"<=")
      "(" ["in"] Type <IDENTIFIER> "," ["in"] Type <IDENTIFIER> ")"
      |
      Type "(" ["in"] Type <IDENTIFIER> ["=" Expression] ")"
   )
   MethodBody
;

DestructorDeclaration :
   (AttributeSection)*
   ["extern" | "unsafe"]
   "~"
   <IDENTIFIER>
   "("
   =>||
   ")"
   MethodBody
;

ConstructorDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.STATIC, TokenType.INTERNAL, TokenType.UNSAFE);
  }#
  (AttributeSection)*
  Modifiers
  <IDENTIFIER>
  "(" =>||
  [FormalParameters]
  ")"
  [
     ":"
     ("base" | "this")
     "(" [ArgumentList] ")"
  ]
  MethodBody
;

StaticConstructorDeclaration :
   (AttributeSection)*
   (
      "extern" ["static"]
      |
      "static" ["extern"]
   )
   <IDENTIFIER>
   "(" =>||
   ")"
   MethodBody
;

ArgumentList : Argument ("," Argument)* ;

Argument :
   (AttributeSection)*
   [=> <IDENTIFIER> ":"]
   (
       // Where is this specified?
      PrimitiveType ASSERT(","|")") =>||
      |
      => "out" Type <IDENTIFIER> // since C# 7.0
      |
      // Not sure since when "in" is allowed here
      ["ref" | "out" | "in"] Expression
   )
;

AddAccessorDeclaration :
    (AttributeSection)*
    ACTIVATE_TOKENS ADD ("add")
    =>||
    AccessorBody
;

RemoveAccessorDeclaration :
    (AttributeSection)*
    ACTIVATE_TOKENS REMOVE ("remove")
    =>||
    AccessorBody
;

PropertyBody :
  "{" (AccessorDeclaration)+ "}"
   ["=" VariableInitializer ";"]
  |
  "=>"
  ["ref"] // since 7.3, I think...
  Expression
  ";"
;

AccessorDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.VIRTUAL, TokenType.OVERRIDE, TokenType.NEW,
                                      TokenType.ABSTRACT, TokenType.INTERNAL, TokenType.READONLY);
  }#
   (AttributeSection)*
   Modifiers
   ACTIVATE_TOKENS GET,SET,INIT ("get" | "set" | "init")
   =>||
   AccessorBody
;

AccessorBody :
   Block
   |
   "=>" ["ref"] Expression ";"
   |
   ";"
;

VariableInitializer :
   Expression
   |
   ArrayInitializer
;

ArrayInitializer :
   "{"
      [VariableInitializer (SCAN 2 "," VariableInitializer)* [","]]
   "}"
;

MethodDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.STATIC,TokenType.UNSAFE, TokenType.VIRTUAL,
                                      TokenType.OVERRIDE, TokenType.NEW, TokenType.ABSTRACT,
                                      TokenType.EXTERN, TokenType.ASYNC, TokenType.INTERNAL,
                                      TokenType.REF, TokenType.READONLY, TokenType.SEALED);
  }#
  (AttributeSection)*
  Modifiers
  [SCAN {checkNextTokenImage("partial")}# => ACTIVATE_TOKENS PARTIAL ("partial")]
  ReturnType
  //MemberName
  Name
  [TypeParameterList]
  "("
  =>||
   [FormalParameters]
  ")"
  TypeParameterConstraints
  MethodBody
;

MethodBody :
   Block
   |
   ["=>" ["ref"] Expression] ";"
;

InterfaceMethodDeclaration :
  {
    permissibleModifiers = EnumSet.of(TokenType.PUBLIC, TokenType.PRIVATE, TokenType.PROTECTED,
                                      TokenType.INTERNAL, TokenType.UNSAFE);
  }#
   (AttributeSection)*
   Modifiers // REVISIT later.
   ReturnType
   <IDENTIFIER>
   [TypeParameterList]
   "(" =>||
   [FormalParameters]
   ")"
   TypeParameterConstraints
   MethodBody // since 8.0. NB. The method body can be a lone semicolon.
;

ReturnType :
   SCAN {getToken(2).getType() != TokenType.STAR}# =>
   // If we have void*, we prefer to parse it as Type
   // for tree-building purposes.
   "void" ["*"]
   |
   Type
;

FormalParameters :
//   SCAN 0 {checkNextTokenImage("__arglist")}#
//   => ACTIVATE_TOKENS ARGLIST (<ARGLIST>)
   ArgListParameter
   |
   ParameterArray
   |
   FixedParameter (=> "," FixedParameter)* ["," VarArgsParameter]
;

VarArgsParameter#void :
   ArgListParameter
   |
   ParameterArray
;


ArgListParameter# :
    <IDENTIFIER>
    ASSERT {getToken(0).getImage().equals("__arglist")}#
    =>||
;

FixedParameter :
   (AttributeSection)*
   ("ref"| "out" | "this"
    | "in" // since 7.2
   )*
   =>|+1
   Type
   <IDENTIFIER>
   ["=" Expression]
;

ParameterArray :
   (AttributeSection)*
   "params" =>||
   ArrayType
   <IDENTIFIER>
;

VariableDeclarator : <IDENTIFIER> ["=" (Expression|ArrayInitializer)] ;

TypeParameterList :
   "<"
   (AttributeSection)*
   ["in"|"out"] // Only with interfaces
   Name
   ("," (AttributeSection)* ["in"|"out"] Name)*
   ">"
;

NonArrayType#void : Type ;

ArrayType#void : Type ;

NonNullableType : Type;

NonTupleType : Type;

Type :
  [=> "delegate" "*"]
  (
    => "void" "*"
    |
    PrimitiveType
    |
    Name
    |
    SCAN ~\NonTupleType
    => TupleType
  )
  ("*")*
  [
     // This is weird. Must REVISIT this.
     SCAN ~\NonNullableType
     => "?"
  ]
  (
     SCAN 2 ~\NonArrayType =>
     ["?"]
     "[" (",")* "]"
  )*
  [
     SCAN 0 \ArrayType =>
     ASSERT {getToken(0).getType() == TokenType.RBRACKET}#
  ]
  (SCAN ~\TupleType => "*")*
  [
     SCAN ~\NonNullableType
     => "?"
  ]
;

TupleType :
   "("
   Type [<IDENTIFIER>]
   ASSERT (",")
   =>||
   ("," Type [<IDENTIFIER>])*
   ")"
;

PrimitiveType#void :
   "bool" | "byte" | "char" | "decimal" | "double" | "float"
   | "int" | "long" | "object" | "sbyte" | "short" | "string"
   |"ushort"|"uint" |"ulong"
;

Block :
  "{"
   ( Statement )*
  "}"
;

Expression#interface :
   SCAN QueryExpressionLA
   =>QueryExpression
   |
   LambdaExpression
   |
   AssignmentExpression
;

INJECT Expression :
{
   /**
    * Can this expression be on the left-hand-side of
    * an assignment?
    */
   default boolean isAssignableTo() {return false;}

   /**
    * Can this expression be evaluated at compile-time?
    */
   default boolean isConstant() {
      for (Node child : children()) {
        if (!(child instanceof Expression)) {
          continue;
        }
        if (!((Expression) child).isConstant()) {
          return false;
        }
      }
      return true;
      // return childrenOfType(Expression.class).stream().allMatch(Expression::isConstant);
   }
}

INJECT AdditiveExpression : implements Expression
INJECT AndExpression : implements Expression
INJECT ArrayCreationExpression : implements Expression
INJECT AnonymousMethodExpression : implements Expression
INJECT AnonymousObjectCreationExpression : implements Expression
INJECT AssignmentExpression : implements StatementExpression
INJECT CheckedExpression : implements StatementExpression
INJECT ConditionalExpression : implements Expression
INJECT ConditionalAndExpression : implements Expression
INJECT ConditionalOrExpression : implements Expression
INJECT DefaultValueExpression : implements Expression
INJECT EqualityExpression : implements Expression
INJECT ExclusiveOrExpression : implements Expression
INJECT InclusiveOrExpression : implements Expression
INJECT LambdaExpression : implements Expression
INJECT Literal : implements Expression
INJECT MultiplicativeExpression : implements Expression
INJECT NameofExpression : implements Expression
INJECT NullCoalescingExpression : implements Expression
INJECT NullForgivingExpression : implements Expression
INJECT NullConditionalExpression : extends UnaryExpression
INJECT ObjectCreationExpression : implements StatementExpression
INJECT OrExpression : implements Expression
INJECT PrimitiveTypeAccess : implements Expression
INJECT RangeExpression : implements Expression
INJECT InterpolatedString : implements Expression
INJECT RegularStringInterpolation : extends InterpolatedString
INJECT MultiStringInterpolation : extends InterpolatedString
INJECT RelationalExpression : implements Expression
INJECT ShiftExpression : implements Expression
INJECT StackAllocInitializer : implements Expression
INJECT StatementExpression : extends Expression
INJECT TypeofExpression : implements Expression
INJECT QualifiedAliasMember : implements Expression
INJECT SizeofExpression : implements Expression
INJECT SwitchExpression : implements Expression
INJECT UncheckedExpression : implements StatementExpression
INJECT UnaryExpression : implements Expression {
   public boolean isAssignableTo() {return true;}
}
INJECT WithExpression : implements Expression
INJECT PostDecrementExpression : extends UnaryExpression implements StatementExpression
INJECT PostIncrementExpression : extends UnaryExpression implements StatementExpression
INJECT PreDecrementExpression : extends UnaryExpression implements StatementExpression
INJECT PreIncrementExpression : extends UnaryExpression implements StatementExpression
INJECT AwaitExpression : extends UnaryExpression implements StatementExpression
INJECT CastExpression : extends UnaryExpression
INJECT ThrowExpression : extends UnaryExpression
INJECT UnaryExpressionNotPlusMinus : extends UnaryExpression
INJECT UnaryExpressionPlusOrMinus : extends UnaryExpression
INJECT FromEndIndex : extends UnaryExpression

INJECT InvocationExpression : implements StatementExpression
{
   public boolean isAssignableTo() {return true;}
}

INJECT LiteralExpression : implements Expression
{
    public boolean isConstant() {return true;}
}

INJECT UnaryExpressionUnsafe : extends UnaryExpression
{
   public boolean isAssignableTo() {return true;}
}

INJECT BaseAccess : implements Expression
{
   public boolean isAssignableTo() {return true;}
}

INJECT Tuple : implements Expression
{
   public boolean isAssignableTo() {return true;}
}

INJECT SimpleName : implements Expression
{
   public boolean isAssignableTo() {return true;}

   public boolean isConstant() {return false;}
}

INJECT This : implements Expression
{
   public boolean isAssignableTo() {return true;}
}

INJECT MemberAccess : implements Expression
{
   public boolean isAssignableTo() {return true;}
}

INJECT PointerMemberAccess : implements Expression
{
   public boolean isAssignableTo() {return true;}
}

INJECT ElementAccess : implements Expression
{
   public boolean isAssignableTo() {return true;}
}

LambdaExpression : LambdaLHS =>|| (Block | Expression) ;

LambdaLHS :
  {boolean seenStatic = false;}
  ["static" {seenStatic = true;}] // since 9.0
  [
     SCAN {checkNextTokenImage("async")}#
     => ACTIVATE_TOKENS ASYNC ("async")
     [
        SCAN {!seenStatic} => "static"
     ]
  ]
  [
     SCAN ("void" | NonNullableType) "("
     => ReturnType
  ]
  (
   =>ImplicitAnonymousFunctionSignature
   |
   ExplicitLambdaSignature
  )
  "=>"
;

ImplicitAnonymousFunctionSignature :
   <IDENTIFIER>
   |
   "(" [<IDENTIFIER> ("," <IDENTIFIER>)*] ")"
;

QueryExpressionLA#scan :
   <IDENTIFIER> ASSERT {getToken(0).getImage().equals("from")}
   (
      <IDENTIFIER> "in"
      |
      Type <IDENTIFIER> "in"
   )
;

QueryExpression :
   ACTIVATE_TOKENS ASCENDING,BY,DESCENDING,EQUALS,FROM,GROUP,JOIN,LET,
                   INTO, ON, ORDERBY,SELECT,WHERE
   (
     FromClause
     QueryBody
   )
;

InQueryExpression#void :
   DEACTIVATE_TOKENS ASCENDING,BY,DESCENDING,EQUALS,FROM,
                   GROUP,JOIN,LET,INTO,
                   ON, ORDERBY
   (Expression)
;

FromClause :
   "from"
   (
      <IDENTIFIER> "in" =>|| InQueryExpression
      |
      Type <IDENTIFIER> "in" InQueryExpression
   )
;

QueryBody :
   ACTIVATE_TOKENS SELECT, GROUP (QueryBodyClause)*
   (
      SelectClause
      |
      GroupClause
   )
   [
      "into"
      <IDENTIFIER>
      QueryBody
   ]
;

QueryBodyClause :
   FromClause
   |
   LetClause
   |
   WhereClause
   |
   JoinClause
   |
   OrderbyClause
;

LetClause : "let" <IDENTIFIER> "=" InQueryExpression ;

WhereClause : "where" InQueryExpression ;

JoinClause :
   "join"
   (
      <IDENTIFIER> "in"
      |
      Type <IDENTIFIER> "in"
   )
   InQueryExpression
   "on"
   InQueryExpression
   "equals"
   InQueryExpression
   ["into" <IDENTIFIER>]
;

SelectClause : "select" InQueryExpression ;

GroupClause : "group" InQueryExpression "by" InQueryExpression;

OrderbyClause :
    "orderby"
    InQueryExpression
    ["ascending"|"descending"]
    (
       "," InQueryExpression ["ascending"|"descending"]
    )*
;

AssignmentExpression :
   ConditionalExpression {Expression lhs = (Expression) peekNode();}
   [
      AssignmentOperator
      ASSERT {lhs.isAssignableTo()} : "Left-hand side is not assignable." :
      ["ref"] // since 7.0 ?
      Expression
   ]
;

MultiplicativeExpression :
   WithExpression
   (
      ("*" | "/" | "%")
      WithExpression
   )*
;

WithExpression :
   SwitchExpression
   [
      SCAN 0 {checkNextTokenImage("with")}#
      => ACTIVATE_TOKENS WITH ("with")
      "{"
      [
         MemberInitializer
         (SCAN 2 "," MemberInitializer)*
         [","]
      ]
      "}"
   ]
;

SwitchExpression :
   RangeExpression
   [
      "switch"
      "{"
         SwitchExpressionCase
         (SCAN 2 "," SwitchExpressionCase)*
         [","]
      "}"
   ]
;

SwitchExpressionCase :
   Expression [WhenClause] "=>" =>|| Expression
   |
   Pattern [WhenClause] "=>" Expression
;

RangeExpression :
   ".." [UnaryExpression]
   |
   UnaryExpression [".." [UnaryExpression]]
;

AdditiveExpression :
   MultiplicativeExpression
   (
      ("+" | "-")
      MultiplicativeExpression
   )*
;

ShiftExpression :
   AdditiveExpression
   (
      ("<<" | ">>")
      AdditiveExpression
   )*
;

RelationalExpression :
   ShiftExpression
   (
      ("<"|">"|"<="|">=") ShiftExpression
      |
      "as" Type
      |
      "is" Pattern
   )*
;

EqualityExpression :
   RelationalExpression
   (
      ("=="|"!=")
      RelationalExpression
   )*
;

AndExpression :
   EqualityExpression
   (
      "&"
      EqualityExpression
   )*
;

ExclusiveOrExpression :
   AndExpression
   (
      "^"
      ExclusiveOrExpression
   )*
;

InclusiveOrExpression :
   ExclusiveOrExpression
   (
      "|"
      ExclusiveOrExpression
   )*
;

ConditionalAndExpression :
   InclusiveOrExpression
   (
      "&&"
      InclusiveOrExpression
   )*
;

ConditionalOrExpression :
    ConditionalAndExpression
    (
       "||"
       ConditionalAndExpression
    )*
;

NullCoalescingExpression :
    ConditionalOrExpression
    (
       "??"
       ConditionalOrExpression
    )*
;

ConditionalExpression :
   NullCoalescingExpression
   [
      "?"
      (
       ["ref"] Expression
       ":"
       ["ref"] Expression
      )
   ]
;

AssignmentOperator #void :
  "="
  | "+="
  | "-="
  | "*="
  | "/="
  | "%="
  | "&="
  | "|="
  | "^="
  | "<<="
  | ">>="
  | "??=" // since 8.0
;

UnaryExpression#abstract :
   UnaryExpressionPlusOrMinus
   |
   UnaryExpressionNotPlusMinus
   |
   CastExpression
   |
   AwaitExpression
   |
   ThrowExpression // since 7.0
   |
   PreIncrementExpression
   |
   PreDecrementExpression
   |
   UnaryExpressionUnsafe
   |
   FromEndIndex
   |
   NullConditionalExpression
;

FromEndIndex :  // since 8.0
    "^" UnaryExpression
;

ThrowExpression# : "throw" [Expression] ;

CastExpression : "(" Type ")" =>|+1 UnaryExpression ;

AwaitExpression :
   SCAN 2 {checkNextTokenImage("await")}#
    =>
   ACTIVATE_TOKENS AWAIT ("await") UnaryExpression
;

UnaryExpressionUnsafe : ("*" | "&") UnaryExpression ;

PreIncrementExpression : "++" UnaryExpression ;

PreDecrementExpression : "--" UnaryExpression ;

UnaryExpressionPlusOrMinus : ("+" | "-") UnaryExpression ;

UnaryExpressionNotPlusMinus : ("!" | "~") UnaryExpression ;

NullConditionalOperations :
   "?" =>|+1
   (
      "." <IDENTIFIER> ["!"][=>TypeArgumentList]
      |
      "[" ArgumentList "]"
   )
   (
      ["?"] "." =>|| <IDENTIFIER> ["!"] [=>TypeArgumentList]
      |
      ["?"] "[" =>|| ArgumentList "]"
      |
      "(" [ArgumentList] ")"
   )*
   ["!"] // since 8.0
;

NullConditionalExpression : PrimaryExpression [NullConditionalOperations] ;

PrimaryExpression#void :
   (
      ArrayCreationExpression
      |
      LiteralExpression
      |
      InterpolatedString
      |
      "this" #This
      |
      BaseAccess
      |
      PrimitiveTypeAccess
      |
      AnonymousMethodExpression
      |
      QualifiedAliasMemberAccess
      |
      NameofExpression
      |
      SimpleName
      |
      StackAllocInitializer // since 8.0
      |
      ParenthesizedOrTuple
      |
      TypeofExpression
      |
      DefaultValueExpression
      |
      CheckedExpression
      |
      SizeofExpression
      |
      UncheckedExpression
      |
      ObjectCreationExpression
      |
      AnonymousObjectCreationExpression
   )
   [
        // since 8.0
        "!" #NullForgivingExpression(2)
   ]
   (
    (
      ("(" [ArgumentList] ")") #InvocationExpression(+1)
      |
      ("[" [=><IDENTIFIER> ":"] Expression ("," [=><IDENTIFIER>":"] Expression)*  "]") #ElementAccess(+1)
      |
      ("." <IDENTIFIER> [=>TypeArgumentList]) #MemberAccess(+1)
      |
      ("->" <IDENTIFIER> [=>TypeArgumentList]) #PointerMemberAccess(+1)
      |
      "++" #PostIncrementExpression(2)
      |
      "--" #PostDecrementExpression(2)
      )
      [
         // since 8.0
        "!" #NullForgivingExpression(2)
      ]
   )*
;

ParenthesizedOrTuple#void :
    => ParenthesizedExpression
    |
    Tuple
;

ArrayCreationExpression :
    SCAN "new" [NonArrayType] "[" =>
    "new"
    (
       RankSpecifier ArrayInitializer
       |
       NonArrayType "[" =>|+1 Expression ("," Expression)* "]" (RankSpecifier)* [ArrayInitializer]
       |
       ArrayType ArrayInitializer
    )
;

ObjectCreationExpression :
   "new" =>|+1 [SCAN 1 {getToken(1).getType() != TokenType.LPAREN} => NonArrayType] // This seems possible since C# 9
   (
      "(" [ArgumentList] ")" [ObjectInitializer | CollectionInitializer]
      |
      (ObjectInitializer | CollectionInitializer)
   )
;

AnonymousObjectCreationExpression :
   "new"
   "{" =>||
    [MemberDeclarator ("," MemberDeclarator)* [","]]
   "}"
;


RankSpecifier : "[" (",")* "]" ;

Tuple :
   "("
   TupleElement =>|+1
   (
      "," TupleElement
   )+
   ")"
;

TupleElement :
   [=> <IDENTIFIER> ":"]
   (
       =>Expression ASSERT ("," | ")")
       |
       =>Type Expression ASSERT ("," | ")")
   )
   =>||
;

PrimitiveTypeAccess :
   ("dynamic" | PrimitiveType)
   "." =>||
   <IDENTIFIER>
   [ => TypeArgumentList ]
;

QualifiedAliasMemberAccess :
   <IDENTIFIER> "::" =>||
   <IDENTIFIER> [TypeArgumentList]
;

BaseAccess :
   "base"
   (
     "." <IDENTIFIER> [TypeArgumentList]
     |
    "[" Expression ("," Expression)* "]"
   )
;

NameofExpression :
   ASSERT {checkNextTokenImage("nameof")}#
   ACTIVATE_TOKENS NAMEOF ("nameof")
   "(" =>||
   NamedEntity
   ")"
;

NamedEntity :
   (SimpleName | "this" | "base" | PredefinedType | QualifiedAliasMember)
   ("." <IDENTIFIER> [TypeArgumentList])*
;

PredefinedType#void :
    "bool" | "byte" | "char"| "decimal" | "double" | "float" | "int"
    | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort"
;

// The "(Type)" part is optional (since C# 7.1)
// if it can be inferred by the compiler.
DefaultValueExpression# : "default" [ "(" Type ")" ] ;

SimpleName# : <IDENTIFIER> [=>TypeArgumentList] ;

ParenthesizedExpression : "(" Expression ")" ;

INJECT ParenthesizedExpression : implements Expression
{
   public boolean isAssignableTo() {
      return ((Expression) getChild(1)).isAssignableTo();
   }
}

TypeofExpression :
    "typeof" "("
    (
       "void"
       |
   // The following expansion is a little bit tricky.
   // If our initial scanahead doesn't find any
   // any empty type args, like <,,,> sort of things,
   // then the assertion at the end fails, and this means
   // that we go to the next choice, which is
   // a regular Type production (with no funky <,,> thingies
       =>UnboundTypeName ASSERT {sawEmptyTypeArgs}#
       |
       Type
    )
    ")"
;

INJECT PARSER_CLASS : {boolean sawEmptyTypeArgs = false;}

UnboundTypeName :
   {sawEmptyTypeArgs = false;}#
   [=> <IDENTIFIER> "::"]
   <IDENTIFIER>
   ["<" (",")* ">" {sawEmptyTypeArgs = true;}#]
   (
      "."
      <IDENTIFIER>
      ["<" (",")* ">" {sawEmptyTypeArgs = true;}#]
   )*
;

MemberDeclarator :
    <IDENTIFIER> "=" =>|| Expression
    |
    PrimaryExpression // TODO ensure that it is of the right type
;


AnonymousMethodExpression :
  {boolean seenStatic = false;}
  ["static" {seenStatic = true;}] // since 9.0
  [
     SCAN {checkNextTokenImage("async")}#
     => ACTIVATE_TOKENS ASYNC ("async")
     [
        SCAN {!seenStatic} => "static"
     ]
  ]
   "delegate"
   =>||
   [
      "("
      [ExplicitAnonymousFunctionSignature]
      ")"
   ]
   Block
;

ExplicitLambdaSignature :
   "("
       ExplicitAnonymousFunctionSignature
   ")"
;

ExplicitAnonymousFunctionSignature :
   ExplicitAnonymousFunctionParameter
   ("," ExplicitAnonymousFunctionParameter)*
;


ExplicitAnonymousFunctionParameter :  (AttributeSection)* ["ref"|"out"|"in"] Type <IDENTIFIER> ;

ObjectInitializer :
  SCAN "{" (QualifiedIdentifier | "[" ArgumentList "]") "="
  =>
  "{"
  MemberInitializer (SCAN 2 "," MemberInitializer)* [","]
  "}"
;

MemberInitializer :
   (QualifiedIdentifier | "[" ArgumentList "]")
   [
      // If this is really optional, it is a mistake in the spec.
      // At least the C# 6.0 spec
     "="
     (Expression | ObjectInitializer | CollectionInitializer)
   ]
;

CollectionInitializer :
   "{"
       [
          ElementInitializer ("," =>|+1 ElementInitializer)* [","]
       ]
   "}"
;

ElementInitializer :
    "{" Expression ("," Expression)* "}"
    |
    Expression // non-assignment, deal with later
;

CheckedExpression : "checked" "(" Expression ")" ;

UncheckedExpression : "unchecked" "(" Expression ")" ;

SizeofExpression : "sizeof" "(" Type ")" ;

LiteralExpression# :
   "true"
   |
   "false"
   |
   "null"
   |
   <INTEGER_LITERAL>
   |
   <REAL_LITERAL>
   |
   <CHARACTER_LITERAL>
   |
   <REGULAR_STRING_LITERAL>
   |
   <VERBATIM_STRING_LITERAL>
;

Label : SCAN 2 <IDENTIFIER> ":" ;

Statement :
   (Label)*
    (
       // REVISIT this
       SCAN {!checkNextTokenImage("await")}#
       =>
       MethodDeclaration
       |
       LocalConstantDeclaration ";"
       |
       LocalVariableDeclaration ";"
       |
       EmbeddedStatement
    )
;

EmptyStatement : ";" ;

EmbeddedStatement :
    Block
    |
    EmptyStatement
    |
    IfStatement
    |
    WhileStatement
    |
    DoStatement
    |
    SCAN 2 {checkNextTokenImage("yield")}#
    => YieldStatement
    |
    CheckedStatement
    |
    UncheckedStatement
    |
    TryStatement
    |
    BreakStatement
    |
    ContinueStatement
    |
    GotoStatement
    |
    ReturnStatement
    |
    ThrowStatement
    |
    UnsafeStatement
    |
    UsingStatement
    |
    LockStatement
    |
    FixedStatement
    |
    SwitchStatement
    |
    ForStatement
    |
    ForeachStatement
    |
    ExpressionStatement
;

LocalVariableDeclarationLA#scan :
   [
      "using"
   ]
   ASSERT {!checkNextTokenImage("await")} // Is there any possibility that a local type is named "await"?
   ["ref"] ["readonly"]
   (
      (
         <IDENTIFIER> ASSERT {getToken(0).getImage().equals("var")}
         (<IDENTIFIER>|Tuple) "="
      )
      |
      (
         Type <IDENTIFIER> ("="|";"|",")
      )
   )
;

LocalVariableDeclaration :
  SCAN LocalVariableDeclarationLA =>
  ["ref"]
  ["using"] // since 8.0
  (
     VarDeclaration
     |
     NoVarDeclaration
  )
;

NoVarDeclaration :
   [
      "ref" // since C# 7.0
   ]
   [
      "readonly" //REVISIT
   ]
   Type
   ASSERT {getToken(-1).getType() == TokenType.DOT || !getToken(0).toString().equals("await")}#
   =>|+1
   LocalVariableDeclarator
   ("," LocalVariableDeclarator)*
;

VarDeclaration :
   [
      "ref" // since C# 7.0
   ]
   [
      "readonly" //REVISIT
   ]
   ACTIVATE_TOKENS VAR ("var")
   =>||
   (<IDENTIFIER>|Tuple) "=" ["ref"] LocalVariableInitializer
;

LocalVariableDeclarator :
   <IDENTIFIER> ["=" ["ref"] LocalVariableInitializer]
;

LocalVariableInitializer :
   Expression
   |
   ArrayInitializer
;

StackAllocInitializer :
   "stackalloc"
   (
      "[" "]" ArrayInitializer
      |
      Type
      (
         SCAN 0 {getToken(0).getType() != TokenType.RBRACKET}#
         => "[" Expression "]"
         |
         "[" Expression "]"
         |
         {}
      )
      [ArrayInitializer]
   )
;

LocalConstantDeclaration :
   "const"
   Type
   ConstantDeclarator
   ("," ConstantDeclarator)*
;

CheckedStatement : "checked" =>|+1 Block ;

UncheckedStatement : "unchecked" =>|+1 Block ;

BreakStatement : "break" ";" ;

ContinueStatement : "continue" ";" ;

GotoStatement :
   "goto"
   (
      <IDENTIFIER>
      |
      "default" #DefaultValueExpression
      |
      "case" Expression
   )
   ";"
;

IfStatement : "if" "(" Expression ")" EmbeddedStatement [ "else" EmbeddedStatement] ;

DoStatement : "do" EmbeddedStatement "while" "(" Expression ")" ";" ;

WhileStatement : "while" "(" Expression ")" EmbeddedStatement ;

ForeachStatement :
   {boolean iteratingOverTupleType=false;}
    [
       //Since 8.0 (I think...)
       SCAN {checkNextTokenImage("await")}#
       => ACTIVATE_TOKENS AWAIT ("await")
    ]
    "foreach" =>||
    "("
    ["ref"]
    (
       "var"
       |
       Tuple {iteratingOverTupleType = true;}
       |
       Type
    )
    (
       <IDENTIFIER>
       |
       SCAN {!iteratingOverTupleType} => Tuple // since ???
       |
       SCAN {iteratingOverTupleType} =>{}
    )
    "in"
    Expression
    ")"
    EmbeddedStatement
;

TryStatement :
   "try" Block
   (
      FinallyClause
      |
      (CatchClause)+ [FinallyClause]
   )
;

ReturnStatement :
   "return"
   [
      [
         // since 7.0. Note that this can only happen in a return statement
         // in a method that was itself declared using ref
         // However, I don't think this is our problem. At least for now.
         // We leave it to the compiler!
         "ref"
      ]
      Expression
   ]
   ";"
;

ThrowStatement : ThrowExpression ";" ;

FinallyClause : "finally" Block ;

UnsafeStatement : "unsafe" Block ;

CatchClause :
   "catch"
   [ "(" Type [<IDENTIFIER>] ")" ]
   [ ACTIVATE_TOKENS WHEN ("when") =>|| "(" Expression ")" ]
   Block
;

YieldStatement :
   ACTIVATE_TOKENS YIELD ("yield")
   (
      "break"
      |
      "return" Expression
   )
   ";"
;

UsingStatement :
   [
      SCAN {checkNextTokenImage("await")}#
      =>ACTIVATE_TOKENS AWAIT ("await")
   ]
   "using"
   {boolean hasParenthesis = false;}
   ["(" {hasParenthesis=true;}]
   =>||
   (
      SCAN LocalVariableDeclaration ")"
      => LocalVariableDeclaration
      |
      Expression
   )
   [SCAN 0 {hasParenthesis} => ")"]
   EmbeddedStatement
;

LockStatement : "lock" "(" Expression ")" EmbeddedStatement ;

FixedStatement :
   "fixed"
   "(" =>||
   Type ASSERT {getToken(0).getType() == TokenType.STAR}
   FixedPointerDeclarator ("," FixedPointerDeclarator)*
   ")"
   EmbeddedStatement
;

FixedPointerDeclarator :
   <IDENTIFIER>
   "=" ["&"] Expression
;

StatementExpression#interface :
   PreIncrementExpression
   |
   PreDecrementExpression
   |
   AwaitExpression
   |
   PrimaryExpression
   {Expression lhs = (Expression) peekNode();}
   (
      NullConditionalOperations #NullConditionalExpression(2)
      |
      SCAN 1 {lhs.isAssignableTo()}
      => (AssignmentOperator ["ref"] Expression) #AssignmentExpression(+1)
      |
      ASSERT {lhs instanceof StatementExpression} : "Not a statement."
   )
   |
   AssignmentExpression
   ASSERT {peekNode() instanceof AssignmentExpression} : "Not a statement."
;

ExpressionStatement : StatementExpression ";" ;

SwitchStatement : "switch" "(" Expression ("," Expression)* ")" SwitchBlock ;

SwitchBlock : "{" (SwitchSection)* "}" ;

SwitchLabel :
   "default" ":"
   |
   // REVISIT: Why do I need this line?
   // The third choice should be enough, it seems...
   => "case" Expression [WhenClause] ":"
   |
   "case" Pattern [WhenClause] ":"
;

WhenClause :
   SCAN 0 {checkNextTokenImage("when")}#
   =>
   ACTIVATE_TOKENS WHEN ("when")
   NullCoalescingExpression
;

SwitchSection :
   (SwitchLabel)+
   (
      SCAN 0 {
         // A bit ugly. Really need to make syntactic lookahead a bit more powerful
         // in terms of negative conditions!
                getToken(1).getType() != TokenType.RBRACE
                && getToken(1).getType() != TokenType.CASE
                && !(getToken(1).getType() == TokenType.DEFAULT && getToken(2).getType() == TokenType.COLON)
             }
      => Statement
   )+
;

ForStatement :
   "for"
   "("
   [LocalVariableDeclaration | StatementExpression ("," StatementExpression)*]
   ";"
   [Expression]
   ";"
   [
      StatementExpression
      ("," StatementExpression)*
   ]
   ")"
   EmbeddedStatement
;

// C# 8 Pattern syntax follows.

Pattern :
   //ACTIVATE_TOKENS AND, OR, NOT, VAR, WHEN (OrPattern)
   ACTIVATE_TOKENS AND, OR, NOT (OrPattern)
;

OrPattern : AndPattern ("or" AndPattern)* ;

AndPattern : NotPattern ("and" NotPattern)* ;

NotPattern : ("not")* PrimaryPattern ;

PrimaryPattern :
   "null" | "true" | "false"
   |
   RelationalPattern
   |
   // These next three options are a bit ugly.
   => CastExpression // Maybe there is a better way but I don't see it.
   |
   => ParenthesizedPattern
   |
   NameofExpression
   |
   DeclarationPattern
   |
   PropertyPattern
   |
   VarPattern
   |
   =>TypePattern
   |
   =>PositionalPattern
   |
   //Which should it be here?
   ShiftExpression
   //InclusiveOrExpression
;

ParenthesizedPattern : "(" Pattern ")" ;

DeclarationPattern :
    NonNullableType
    ASSERT {checkNextTokenType(TokenType.IDENTIFIER)}#
    ACTIVATE_TOKENS FROM, WHERE
    (
       ASSERT ~(FromClause)
       ASSERT ~(WhenClause)
    )
    <IDENTIFIER>
    =>||
;

VarPattern :
    SCAN 0 {checkNextTokenImage("var")}# =>
    ACTIVATE_TOKENS VAR ("var")
    (<IDENTIFIER> | Tuple)
;

TypePattern :
   (
      Type
      [
         SCAN {getToken(0) instanceof NODE_PACKAGE.PrimitiveType}#
         => "." <IDENTIFIER>
      ]
      {
         TokenType lastTokType = getToken(0).getType();
         TokenType nextTokType = getToken(1).getType();
      }#
      ASSERT
      {
         // If we have a left parentheis, this choice fails
         // and we go to PositionalPattern
         nextTokType != TokenType.LPAREN
         &&
         (
            lastTokType != TokenType.HOOK
         // This is now really grotesque!
         // If the Type we matched is "nullable", i.e.
         // ends in a ?  // then the token after that must be
         // one of the following half dozen types
         // Otherwise we effectively backtrack
         // and match the Type as a NonNullableType,
         // i.e. we parse it without the trailing "?"
            || nextTokType == TokenType.HOOK
            || nextTokType == TokenType.RPAREN
            || nextTokType == TokenType.SEMICOLON
            || nextTokType == TokenType.EQ
            || nextTokType == TokenType.SC_OR
            || nextTokType == TokenType.SC_AND
            || nextTokType == TokenType.COMMA
            || checkNextTokenImage("and")
            || checkNextTokenImage("or")
         )
      }# =>||
      |
      NonNullableType ASSERT {getToken(1).getType() != TokenType.LPAREN}#
   )
;

RelationalPattern : (">"|">="|"<="|"<") RelationalExpression ;

PositionalPattern :
    [=>NonTupleType]
    "("
    [SubPatterns]
    ")"
    [PropertySubPattern]
    [SCAN {!checkNextTokenImage("when") || !isInProduction("SwitchExpressionCase", "SwitchLabel")}# => <IDENTIFIER>]
;

SubPatterns :
   [=> QualifiedIdentifier ":"]
   Pattern
   (
      SCAN 2
      ","
      [=> QualifiedIdentifier ":"]
      Pattern
   )*
;

PropertyPattern :
   [Type] =>|+1 PropertySubPattern
   [
      SCAN {!checkNextTokenImage("when") || !isInProduction("SwitchExpression", "SwitchStatement")}#
      =><IDENTIFIER>
   ]
;

PropertySubPattern :
   "{"
    [SubPatterns [","]]
   "}"
;

InterpolatedString#abstract : RegularStringInterpolation | MultiStringInterpolation ;

RegularStringInterpolation :
   <REGULAR_INTERPOLATION_START>
   LEXICAL_STATE IN_REGULAR_INTERPOLATION
   (
      (
         RegularNonInterpolatedText
         |
         PlaceHolder
      )*
      <ENDING_QUOTE>
   )
;

MultiStringInterpolation :
   <MULTI_INTERPOLATION_START>
   LEXICAL_STATE IN_MULTI_INTERPOLATION
   (
      (
         MultiNonInterpolatedText
         |
         PlaceHolder
      )*
      <ENDING_QUOTE>
   )
;

PlaceHolder :
   "{"
   LEXICAL_STATE CSHARP
   (
      Expression
      ["," Expression]
      [
         ":"
         RegularNonInterpolatedText
      ]
      "}"
   )
;

RegularNonInterpolatedText :
   LEXICAL_STATE IN_REGULAR_INTERPOLATION
   (<NON_INTERPOLATED_TEXT>)
;

MultiNonInterpolatedText : IN_MULTI_INTERPOLATION :
   <NON_INTERPOLATED_TEXT2>
;
