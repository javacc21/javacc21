/* Generated by: JavaCC 21 Parser Generator. Do not edit. BaseNode.java */
package org.parsers.json;

import java.util.*;
/**
 * The base concrete class for non-terminal Nodes
 */
@SuppressWarnings("rawtypes")
public class BaseNode implements Node {
    private String inputSource;
    public String getInputSource() {
        return inputSource;
    }

    public void setInputSource(String inputSource) {
        this.inputSource= inputSource;
    }

    static private Class listClass= ArrayList.class;
    /**
     * Sets the List class that is used to store child nodes. By default,
     * this is java.util.ArrayList. There is probably very little reason
     * to ever use anything else, though you could use this method 
     * to replace this with LinkedList or your own java.util.List implementation even.
     * @param listClass the #java.util.List implementation to use internally 
     * for the child nodes. By default #java.util.ArrayList is used.
     */
    static public void setListClass(Class<?extends List> listClass) {
        BaseNode.listClass= listClass;
    }

    @SuppressWarnings("unchecked")
    private List<Node> newList() {
        try {
            return(List<Node> ) listClass.getDeclaredConstructor().newInstance();
        }
        catch(Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * the parent node
     */
    protected Node parent;
    /**
     * the child nodes
     */
    protected List<Node> children= newList();
    private int beginLine, beginColumn, endLine, endColumn;
    private Map<String, Object> attributes;
    private boolean unparsed;
    public boolean isUnparsed() {
        return this.unparsed;
    }

    public void setUnparsed(boolean unparsed) {
        this.unparsed= unparsed;
    }

    public void open() {
    }

    public void close() {
    }

    public void setParent(Node n) {
        parent= n;
    }

    public Node getParent() {
        return parent;
    }

    public void addChild(Node n) {
        children.add(n);
        n.setParent(this);
    }

    public void addChild(int i, Node n) {
        children.add(i, n);
        n.setParent(this);
    }

    public Node getChild(int i) {
        return children.get(i);
    }

    public void setChild(int i, Node n) {
        children.set(i, n);
        n.setParent(this);
    }

    public Node removeChild(int i) {
        return children.remove(i);
    }

    public void clearChildren() {
        children.clear();
    }

    public int getChildCount() {
        return children.size();
    }

    public List<Node> children() {
        return Collections.unmodifiableList(children);
    }

    public Object getAttribute(String name) {
        return attributes== null?null:
        attributes.get(name);
    }

    public void setAttribute(String name, Object value) {
        if (attributes== null) {
            attributes= new HashMap<String, Object> ();
        }
        attributes.put(name, value);
    }

    public boolean hasAttribute(String name) {
        return attributes== null?false:
        attributes.containsKey(name);
    }

    public Set<String> getAttributeNames() {
        if (attributes== null) return Collections.emptySet();
        return attributes.keySet();
    }

    public int getBeginLine() {
        if (beginLine<=0) {
            if (!children.isEmpty()) {
                beginLine= children.get(0).getBeginLine();
                beginColumn= children.get(0).getBeginColumn();
            }
        }
        return beginLine;
    }

    public int getEndLine() {
        if (endLine<=0) {
            if (!children.isEmpty()) {
                Node last= children.get(children.size()-1);
                endLine= last.getEndLine();
                endColumn= last.getEndColumn();
            }
        }
        return endLine;
    }

    public int getBeginColumn() {
        if (beginColumn<=0) {
            if (!children.isEmpty()) {
                beginLine= children.get(0).getBeginLine();
                beginColumn= children.get(0).getBeginColumn();
            }
        }
        return beginColumn;
    }

    public int getEndColumn() {
        if (endColumn<=0) {
            if (!children.isEmpty()) {
                Node last= children.get(children.size()-1);
                endLine= last.getEndLine();
                endColumn= last.getEndColumn();
            }
        }
        return endColumn;
    }

    public void setBeginLine(int beginLine) {
        this.beginLine= beginLine;
    }

    public void setEndLine(int endLine) {
        this.endLine= endLine;
    }

    public void setBeginColumn(int beginColumn) {
        this.beginColumn= beginColumn;
    }

    public void setEndColumn(int endColumn) {
        this.endColumn= endColumn;
    }

    public String toString() {
        StringBuilder buf= new StringBuilder();
        for (Token t : getRealTokens()) {
            buf.append(t);
        }
        return buf.toString();
    }

}
