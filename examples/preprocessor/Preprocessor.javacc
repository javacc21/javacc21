/*
 * Authors: Jonathan Revusky revusky@javacc.com
 *          Vinay Sajip vinay_sajip@yahoo.co.uk - adapted to allow string values for symbols
 * This partial implementation of the C# Preprocessor
 * is free to use or adapt.
 */

DEFAULT_LEXICAL_STATE = PP_SCAN_LINES;
TREE_BUILDING_ENABLED=false;
ENSURE_FINAL_EOL;
MINIMAL_TOKEN;
#if localtest
PARSER_PACKAGE="org.parsers.preprocessor";
#else
PARSER_PACKAGE="com.javacc.preprocessor";
#endif

/*
 * This is an implementation of the standard C# preprocessor.
 * Well, it is incomplete at the moment, because it just ignores
 * everything except #define/#undef and #if/#elif/#else. 
 * The other C# pre-processing directives, #pragma, #region/#endregion, 
 * #warning/#error and #line are just treated as lines to ignore.
 * So the only thing currently supported is turning on or off 
 * parts of the source file.
 * This is very bare-bones and bloody-minded. It does not build a
 * tree or any of that. It just uses code actions to create a BitSet
 * that holds whether a line is "turned on" or not. The line offsets
 * are 1-based.
 *
 * All the naming in this file is prefixed with PP_, sort of using the 
 * poor man's namespace functionality. This is because I anticipate
 * this getting INCLUDEd and I don't want to stomp on other people's
 * names. It is not terribly optimal and really quite ugly. Something 
 * should eventually be done about this.
 */

INJECT PARSER_CLASS : 
{
    private final BitSet lineMarkers = new BitSet();
    private final Map<String, String> definedSymbols = new HashMap<>();
    private boolean currentlyOn = true;
    private boolean csharpMode = false;

    public PARSER_CLASS(Path path, Map<String, String> definedSymbols, boolean csharpMode) throws IOException {
        this(path);
        this.csharpMode = csharpMode;
        if (definedSymbols !=null) addSymbols(definedSymbols);
        token_source.switchTo(LexicalState.PP_SCAN_LINES);
    }

    public BitSet getLineMarkers() {
        return lineMarkers;
    }

    private void setLineMarker() {
        int lineNumber = lastConsumedToken.getBeginLine();
        if (currentlyOn) lineMarkers.set(lineNumber);
    }

    public void setSymbol(String symbol, String value) {
        definedSymbols.put(symbol, value);
    }

    public void unsetSymbol(String symbol) {
        definedSymbols.put(symbol, "0");
    }

    public void addSymbols(Map<String, String> symbols) {
        definedSymbols.putAll(symbols);
    }

    private static class Expression {
        boolean booleanValue;
        String symbol;
    }
}

TOKEN : 
 <#PP_WS : [" ", "\t", "\f"] >
 |
 <#PP_EOL : "\n" | "\r" | "\r\n" >
 |
 <PP_LINE : (<PP_WS>)* ((~["#", " ", "\t", "\f", "\n", "\r"]) (~["\n", "\r"])*)? <PP_EOL>>
 |
 <PP_DEFINE : <PP_START> "define" (<PP_WS>)*> : PP_DIRECTIVE 
 |
 <PP_UNDEF : <PP_START> "undef" (<PP_WS>)*> : PP_DIRECTIVE 
 |
 <PP_IF : <PP_START> "if" (<PP_WS>)*> : PP_DIRECTIVE 
 |
 <PP_ELIF : <PP_START> "elif" (<PP_WS>)*> : PP_DIRECTIVE 
 |
 <PP_ELSE : <PP_START> "else"> : PP_DIRECTIVE
 |
 <PP_ENDIF : <PP_START> "endif"> : PP_DIRECTIVE
;

UNPARSED :
 <PP_IGNORED_DIRECTIVE : 
     <PP_START> 
// Just ignore all these for now.     
     ("pragma" | "line" | "warning" | "error" | "region" | "endregion" | "nullable") 
     (~["\n", "\r"])* 
     <PP_EOL>>
;
 

MORE :
//Anything else that looks like it starts a directive,
// we just treat (rightly or wrongly) as a line of code
// that is NOT ignored.
  <PP_START : (<PP_WS>)* "#" (<PP_WS>)*> : PP_EAT_TO_EOL
;

<PP_EAT_TO_EOL> TOKEN :
  <PP_FALSE_ALERT : ((~["\n", "\r"])*)? <PP_EOL>> : PP_SCAN_LINES 
;

INCLUDE NON_EXISTENT ! JAVA_IDENTIFIER_DEF

<PP_DIRECTIVE> TOKEN : 
    <PP_TRUE : "true">
    |
    <PP_FALSE : "false">
    |
    <PP_SYMBOL : <JAVA_IDENTIFIER_START> (<JAVA_IDENTIFIER_PART>)* >
    |
    <PP_OR : "||">
    |
    <PP_AND : "&&">
    |
    <PP_LPAREN : "(">
    |
    <PP_RPAREN : ")">
    |
    <PP_ASSIGN : "=">
    |
    <PP_EQUALS : "==">
    |
    <PP_NOT_EQUALS : "!=">
    |
    <PP_NOT : "!"> 
;

<PP_DIRECTIVE> UNPARSED : 
    <PP_EOL_COMMENT : ("//" (~["\n", "\r"])*)? <PP_EOL>> : PP_SCAN_LINES
;

<PP_DIRECTIVE> SKIP : " " | "\t" | "\f" ;

BitSet PP_Root#void : PP_Block <EOF> {return lineMarkers;};

PP_Block#void : (PP_IfBlock | PP_DefStatement | PP_UndefStatement | PP_Content)* ;

PP_Content#void : ((<PP_LINE>|<PP_FALSE_ALERT>) {setLineMarker();})+ ;

PP_IfBlock#void :
   {
      boolean alreadyHandled = false;
      Expression result;
      final boolean previouslyOn = currentlyOn;
   }
    <PP_IF>
    result = PP_Expression {
        if (result.booleanValue) alreadyHandled = true;
        currentlyOn = result.booleanValue && previouslyOn;
    }
    PP_Block {if (alreadyHandled) currentlyOn = false;} 
    (
        <PP_ELIF> result=PP_Expression 
        {
            if (!alreadyHandled) {
                alreadyHandled = result.booleanValue;
                currentlyOn = previouslyOn && result.booleanValue;
            }
        }
        PP_Block
    )* 
    [
        <PP_ELSE> {currentlyOn = !alreadyHandled && previouslyOn;}
        PP_Block
    ]
    <PP_ENDIF>
    {this.currentlyOn = previouslyOn;}
;

PP_DefStatement#void :
{
    String value = "1";
}
  <PP_DEFINE> <PP_SYMBOL>
  [
    <PP_ASSIGN>
    <PP_SYMBOL> {
      if (csharpMode) {
        throw new ParseException("Symbols cannot have defined values in C# mode.");
      }
      value = lastConsumedToken.getImage();
    }
  ]
  {
    if (currentlyOn) {
      definedSymbols.put(lastConsumedToken.getImage(), value);
    }
  }
;

PP_UndefStatement#void : 
    <PP_UNDEF> <PP_SYMBOL> 
    {if (currentlyOn) definedSymbols.remove(lastConsumedToken.getImage());}
;    

Expression PP_Expression#void :
  {
    Expression result, result2;
    boolean inequality = false;
  }
  result=PP_OrExpression
  [
    (<PP_EQUALS>|<PP_NOT_EQUALS>{inequality=true;}) 
    result2=PP_OrExpression 
    {
      if (csharpMode || result.symbol == null || result2.symbol == null) {
        result.booleanValue = inequality == (result.booleanValue != result2.booleanValue);
      }
      else {
        // Not C# mode, and LHS and RHS are symbols
        String key = result.symbol;
        String value = result2.symbol;

        result.symbol = null;   // don't propagate further
        result2.symbol = null;
        if (!definedSymbols.containsKey(key)) {
          if (!definedSymbols.containsKey(value)) {
            // neither LHS nor RHS appears to be defined, so both are
            // logically false, so ...
            result.booleanValue = !inequality;
          }
          else {
            // LHS isn't defined, so logically false. RHS is defined,
            // but its value might be "0" because it was undef'ed.
            result.booleanValue = inequality != definedSymbols.get(value).equals("0");
          }
        }
        else {
          String keyValue = definedSymbols.get(key);
          result.booleanValue = inequality != value.equals(keyValue);
        }
      }
    }
  ]
  {return result;}
;

Expression PP_OrExpression#void :
  { Expression result, result2; }
   result=PP_AndExpression 
  (<PP_OR> result2 = PP_AndExpression { result.booleanValue = result.booleanValue || result2.booleanValue; })*
   {return result;}
;

Expression PP_AndExpression#void :
  { Expression result, result2; }
   result=PP_NotExpression 
  (<PP_AND> result2 = PP_NotExpression { result.booleanValue = result.booleanValue && result2.booleanValue; })*
   {return result;}
;   

Expression PP_NotExpression#void :
  {
    boolean not = false;
    Expression result;
  }
   (<PP_NOT> {not = !not;})* 
   result=PP_PrimaryExpression 
  {
     if (not) {
       result.booleanValue = !result.booleanValue;
     }
     return result;
  }
;

Expression PP_Parentheses#void :
   { Expression result; }
   <PP_LPAREN> 
   result=PP_Expression 
   <PP_RPAREN> 
   {return result;}
;

Expression PP_PrimaryExpression#void :
    { Expression result = new Expression(); }
    (
      result=PP_Parentheses
      |
      <PP_SYMBOL> 
      {
        result.symbol = lastConsumedToken.getImage();
        result.booleanValue = definedSymbols.containsKey(result.symbol);
      }
      |
      <PP_TRUE> { result.booleanValue = true; }
      |
      <PP_FALSE> { result.booleanValue = false; }
    )
    {return result;}
; 
