/* Copyright (c) 2008-2021 Jonathan Revusky, revusky@javacc.com
 * Copyright (c) 2006, Sun Microsystems Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky, Sun Microsystems, Inc.
 *       nor the names of any contributors may be used to endorse or promote
 *       products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

   #define artsy // Since I couldn't be bothered to write a separate unit test for the preprocessor...

#if artsy   
  TREE_BUILDING_ENABLED;
  ENSURE_FINAL_EOL;
#endif

#undef artsy

#if artsy
   May I compare thee to a Summer's day?
   Thou art more beautiful..
#elif foobar && artsy
   I'm just testing the preprocessor a bit!
 #else
JAVA_UNICODE_ESCAPE;
FREEMARKER_NODES;
PARSER_PACKAGE=com.javacc.parser;
NODE_PACKAGE=com.javacc.parser.tree;
DEFAULT_LEXICAL_STATE=JAVA;
BASE_SRC_DIR="../java";
//JDK_TARGET=11;
#endif 

//FAULT_TOLERANT=true;

INJECT PARSER_CLASS :
    import java.util.*;
    import java.nio.file.Path;
    import com.javacc.*;
    import com.javacc.core.*;
    import com.javacc.parser.tree.*;
    import com.javacc.preprocessor.PreprocessorParser;
{
    Grammar grammar;
    
    public PARSER_CLASS(Grammar grammar, Path path, Map<String, String> definedSymbols) throws IOException {
        this(path.toString(), path);
        this.grammar = grammar;
        BitSet lineMarkers = null;
        try {
            PreprocessorParser ppp = new PreprocessorParser(path, definedSymbols, false);
            lineMarkers = ppp.PP_Root();
        } catch (com.javacc.preprocessor.ParseException pe) {
            throw new RuntimeException(pe);
        }
        token_source.input_stream.setParsedLines(lineMarkers);
    }

    public PARSER_CLASS(Grammar grammar, String inputSource, CharSequence content) {
         this(inputSource, content);
         this.grammar = grammar;
         BitSet lineMarkers = null;
         try {
             lineMarkers = new PreprocessorParser(content).PP_Root();
         } catch(com.javacc.preprocessor.ParseException pe) {
             throw new RuntimeException(pe);
         }
         token_source.input_stream.setParsedLines(lineMarkers);
    }

    static public CompilationUnit parseJavaFile(java.io.Reader input, String inputSource) throws ParseException {
        try {
            String content = FileLineMap.readFully(input);
            return parseJavaFile(inputSource, content);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }
    
    static public CompilationUnit parseJavaFile(String inputSource, CharSequence content) throws ParseException {
        PARSER_CLASS parser = new PARSER_CLASS(inputSource, content);
        return parser.CompilationUnit();
    }

    static public CompilationUnit parseJavaFile(Path path) throws ParseException, IOException {
        PARSER_CLASS parser = new PARSER_CLASS(path);
        return parser.CompilationUnit();
    }

    public Grammar getGrammar() {
        return grammar;
    }
    
    public void openNodeScopeHook(Node n) {
        n.setGrammar(grammar);
    }
}

/* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */

TOKEN :
{
  < _INJECT: "INJECT" > #JavaCCKeyWord
  |
  < _INCLUDE : "INCLUDE" | "INCLUDE_GRAMMAR"> #JavaCCKeyWord
  |
  < _LOOKAHEAD: "LOOKAHEAD" > #JavaCCKeyWord
  |
  < _FAIL : "FAIL" > #JavaCCKeyWord
  |
  < _ACTIVATE_TOKENS : "ACTIVATE_TOKENS"> #JavaCCKeyWord
  |
  < _DEACTIVATE_TOKENS : "DEACTIVATE_TOKENS"> #JavaCCKeyWord
  |
  < _ENSURE : "ASSERT"> #JavaCCKeyWord
  |
  < _SCAN : "SCAN" > #JavaCCKeyWord
  |
  < _IGNORE_CASE: "IGNORE_CASE" > #JavaCCKeyWord
  |
  < _NO_NFA : "NO_NFA"> #JavaCCKeyWord
  |
  < _PARSER_BEGIN: "PARSER_BEGIN" > #JavaCCKeyWord
  |
  < _PARSER_END: "PARSER_END" > #JavaCCKeyWord
  |
  < _TOKEN: "TOKEN" | "REGULAR_TOKEN"> #JavaCCKeyWord
  |
  < _SPECIAL_TOKEN: "SPECIAL_TOKEN" | "UNPARSED"> #JavaCCKeyWord
  |
  < _MORE: "MORE" | "INCOMPLETE_TOKEN" > #JavaCCKeyWord
  |
  < _SKIP: "SKIP" > #JavaCCKeyWord
  |
  <_EOF : "EOF"> #JavaCCKeyWord
  |
  < _TOKEN_MGR_DECLS: "TOKEN_MGR_DECLS" > #JavaCCKeyWord
  |
  < _ATTEMPT: "ATTEMPT"> #JavaCCKeyWord
  |
  < _RECOVER : "RECOVER"> #JavaCCKeyWord
  |
  < _RECOVER_TO : "RECOVER_TO"> #JavaCCKeyWord
  |
  < _ON_ERROR : "ON_ERROR"> #JavaCCKeyWord
  |
  < _UPTO : "UPTO"> #JavaCCKeyWord
  |
  <HASH : "#">
  |
  <BACKSLASH : "\\"> #Backslash
  |
  <RIGHT_ARROW : "=>"> #RightArrow
  |
  <UP_TO_HERE : "=>|" ("|" | ("+" ["0"-"9"]))> 
  |
  <_LEXICAL_STATE : "LEXICAL_STATE"> #JavaCCKeyWord
}

INJECT BaseNode :
    import java.util.*;
    import freemarker.template.*;
    import java.lang.reflect.*;
    import com.javacc.Grammar;
    import NODE_PACKAGE.KeyWord;
    implements Node, TemplateHashModel, CONSTANTS_CLASS;
{
    public TemplateModel get(String key) throws TemplateModelException {
        String methodName = "get" + key.substring(0,1).toUpperCase() + key.substring(1);
        TemplateModel result = invokeMethod(methodName);
        if (result == null) {
            result = invokeMethod(methodName.replace("get", "is"));
        }
        return result;
   }
    
    private TemplateModel invokeMethod(String methodName) throws TemplateModelException {
        Method method = null;
        try {
            method = this.getClass().getMethod(methodName);
        } catch (NoSuchMethodException e) {
            return null;
        }
        try {
            Object result = method.invoke(this);
            TemplateModel wrappedResult = Configuration.getCurrentObjectWrapper().wrap(result);
            if (methodName.startsWith("is") && !(wrappedResult instanceof TemplateBooleanModel)) {
                return null; //Maybe should throw an exception here, or maybe it doesn't matter.
            }
            return wrappedResult;
        } catch (IllegalAccessException e) {
            throw new TemplateModelException(e);
        } catch (InvocationTargetException e) {
            Throwable cause = e.getCause();
            if (cause instanceof TemplateModelException) {
                throw (TemplateModelException) cause;
            }
            if (cause instanceof Exception) {
                throw new TemplateModelException((Exception) cause);
            }
            throw (Error) cause;
        }
    } 
    
    private Grammar grammar;

    public Grammar getGrammar() {
        if (grammar == null) {
            if (parent != null) {
               grammar = parent.getGrammar();
            }
            if (grammar==null && !children.isEmpty()) {
               grammar = children.get(0).getGrammar();
            }
        }
        return grammar;
    }

    public void setGrammar(Grammar grammar) {
         this.grammar = grammar;
    }
    
    public String getSimpleName() {
        String name = getClass().getName();
        return name.substring(name.lastIndexOf(".") + 1); // strip the package name
    }
    
    protected String getInnerText() {
        StringBuilder buf = new StringBuilder();
        List<Token> tokens = getAllTokens(true);
        boolean outputOpeningBrace = false;
        for (int i=0; i<tokens.size() -1; i++) {
            Token t = tokens.get(i);
            if (outputOpeningBrace) {
                buf.append(t);
            } else if (t.getType() == TokenType.LBRACE) {
                outputOpeningBrace = true;
            }
        }
        return buf.toString();
    }

    // REVISIT. Need to fix the token chaining    
    public void prepend(Node n) {
        ListIterator<Node> iterator = iterator();
        iterator.add(n);
    }
    
    public String getAsString() {
        return getLiteralText();
    }
    
    public boolean isEmpty() {
        return getRealTokens().isEmpty();
    }

    public boolean hasKeyWord(String keyWord) {
        for (KeyWord kw: childrenOfType(KeyWord.class)) {
           if (kw.getImage().equals(keyWord)) return true;
        }
        return false;
    }

    protected String getLiteralText() {
        StringBuilder buf = new StringBuilder();
        for (Token t : getAllTokens(true)) {
            buf.append(t);
        }
        return buf.toString();
    }
}

INJECT CompilationUnit : 
    import java.util.*;
{
    public String getPackageName() {
        PackageDeclaration jpd = getPackageDeclaration();
        return jpd == null ?  null : jpd.getPackageName();
    }
    
    
    public PackageDeclaration getPackageDeclaration() {
        return firstChildOfType(PackageDeclaration.class);
    }
    
    public List<ImportDeclaration> getImportDeclarations() {
        return childrenOfType(ImportDeclaration.class);
    }
    
    public List<TypeDeclaration> getTypeDeclarations() {
        return childrenOfType(TypeDeclaration.class);
    }

    public void addImportDeclaration(ImportDeclaration decl) {
        Node firstTypeDeclaration = firstChildOfType(TypeDeclaration.class);
        if (firstTypeDeclaration == null) {
          firstTypeDeclaration = firstChildOfType(Delimiter.class); //lone semicolon, I suppose
        }
        addChild(indexOf(firstTypeDeclaration), decl);
    }
}

INJECT TypeDeclaration : 
    import java.util.*;
{
    public String getName() {
        return firstChildOfType(Identifier.class).toString();
    }
    
    public TypeParameters getTypeParameters() {
        return firstChildOfType(TypeParameters.class);
    }
    
    public ClassOrInterfaceBody getBody() {
        return firstChildOfType(ClassOrInterfaceBody.class);
    }
    
    public ExtendsList getExtendsList() {
        return firstChildOfType(ExtendsList.class);
    }
    
    public ImplementsList getImplementsList() {
        return firstChildOfType(ImplementsList.class);
    }
    
    public CompilationUnit getCompilationUnit() {
        return firstAncestorOfType(CompilationUnit.class);
    }
    
    public List<ImportDeclaration> getImportDeclarations() {
        CompilationUnit jcu = getCompilationUnit();
        return jcu==null ? new ArrayList<ImportDeclaration>() : jcu.getImportDeclarations();
    }
}

INJECT FormalParameters : 
   import java.util.List;
{
    public List<FormalParameter> getParams() {
        return childrenOfType(FormalParameter.class);
    }
    
    public String getAsString() {
        StringBuilder buf = new StringBuilder();
        List<FormalParameter> params = getParams();
        boolean first = true;
        for (FormalParameter param : params) {
            if (!first) {
                buf.append(", ");
            }
            buf.append(param.getAsString());
            first = false;
        }
        return buf.toString();
    }
    
    public String toString() {
        StringBuilder buf = new StringBuilder();
        for (Token tok : getRealTokens()) {
            buf.append(" ");
            buf.append(tok);
        }
        return buf.toString();
    }
}

INJECT ImplementsList : 
   import java.util.*;
{    
    public List<ObjectType> getTypes() {
        return childrenOfType(ObjectType.class);
    }
    //REVISIT. fix token chaining    
    public void addType(ObjectType type) {
        ListIterator<Node> iterator = iterator();
        if (!iterator.hasNext()) {
            iterator.add(Token.newToken(TokenType.IMPLEMENTS, "implements", this));
            iterator.next();
            iterator.add(type);
        } else {
            while (iterator.hasNext()) {
                if (type.equals(iterator.next())) 
                    return;
            }
            iterator.add(Token.newToken(TokenType.COMMA, ",", this));
            iterator.next();
            iterator.add(type);
        }
    }
}

INJECT CodeBlock :
{
    public String getAsString() {
        return getInnerText();
    }
    
    /**
     * The block is empty if it only consists of { and }
     */
    public boolean isEmpty() {
        return getRealTokens().size() == 2;
    }
}

INJECT InvocationArguments : 
    import java.util.*;
{
    public List<Expression> getArgs() {
        return childrenOfType(Expression.class);
    }

    public String getAsString() {
        StringBuilder buf = new StringBuilder();
        List<Expression> args = getArgs();
        boolean first = true;
        for (Expression arg : args) {
            if (!first) {
                buf.append(", ");
            }
            buf.append(arg.getAsString());
            first = false;
        }
        return buf.toString();
    }
}

INCLUDE JAVA

INJECT TypeDeclaration : 
    import java.util.*;
{
    public void addElements(List<ClassOrInterfaceBodyDeclaration> elements) {
        Set<String> keys = new HashSet<String>();
        for (ClassOrInterfaceBodyDeclaration decl : elements) {
            String key = decl.getFullNameSignatureIfMethod();
            if (key != null) {
                keys.add(key);
            }
        }
        //REVISIT. fix token chaining
        for (Iterator<Node> it = getBody().iterator(); it.hasNext();) {
            Node n = it.next();
            if (n instanceof ClassOrInterfaceBodyDeclaration) {
                String s = ((ClassOrInterfaceBodyDeclaration) n).getFullNameSignatureIfMethod();
                if (keys.contains(s)) {
                    it.remove();
                }
            }
        }
        getBody().prepend(elements);
    }
    
   public void addAnnotations(Set<Annotation> annotations) {
       Node parent = this.getParent();
       int index = parent.indexOf(this);
       //REVISIT. fix token chaining
       for (Annotation annotation : annotations) {
           parent.addChild(index, annotation);
       }
   } 
   
    
    public boolean isClass() {
        for (Node n : children) {
        if (n instanceof Token) {
           Token t = (Token) n;
               if (t.getType() == TokenType.CLASS) {
                  return true;
               }
        }
        }
        return false;
    }
    
    public void addImplements(ObjectType type) {
        ImplementsList implementsList = getImplementsList();
        if (implementsList == null) {
           implementsList = new ImplementsList();
           ListIterator<Node> iterator = iterator();
           while (iterator.hasNext()) {
              Node node = iterator.next();
              if (node instanceof ClassOrInterfaceBody || node instanceof EnumBody)
                  break; 
           }
           iterator.previous();
           iterator.add(implementsList);
        }
        implementsList.addType(type);
    }

    public void addExtends(ObjectType type) {
        ExtendsList extendsList = getExtendsList();
        if (extendsList == null) {
            extendsList = new ExtendsList();
            ListIterator<Node> iterator = iterator();
            while (iterator.hasNext()) {
                Node node = iterator.next();
                if (node instanceof ImplementsList || node instanceof ClassOrInterfaceBody) {
                    break;
                }
            }
            iterator.previous();
            iterator.add(Token.newToken(TokenType.WHITESPACE, " ", this));
            iterator.next();
            iterator.add(extendsList);
        }
        extendsList.addType(type, this instanceof InterfaceDeclaration);
    }
}

INJECT ExtendsList : 
     import java.util.*;
{
    //REVISIT. fix token chaining 
    
      public void addType(ObjectType type, boolean isInterface) {
        if (!isInterface) {
            children = new java.util.ArrayList<Node>();
        }
        ListIterator<Node> iterator = iterator();
        if (!iterator.hasNext()) {
            iterator.add(Token.newToken(TokenType.EXTENDS, "extends", this));
            iterator.next();
            iterator.add(type);
        } else {
            while (iterator.hasNext()) {
                if (type.equals(iterator.next())) 
                    return;
            }
            iterator.add(Token.newToken(TokenType.COMMA, ",", this));
            iterator.next();
            iterator.add(type);
        }
    }
}

INJECT TypeParameters : 
    import java.util.*;
{
    // REVISIT. fix token chaining
    
    public void add(TypeParameter param) {
        if (!getParameters().contains(param)) {
            ListIterator<Node> iterator = iterator();
            while(iterator.hasNext()) {
                iterator.next();
            }
            iterator.previous();
            iterator.add(Token.newToken(TokenType.COMMA, ",", this));
            iterator.next();
            iterator.add(param);
        }
    }

    // REVISIT. fix token chaining 
    public void add(TypeParameters params) {
        for (TypeParameter param : params.getParameters()) {
            add(param);
        }
    }
}

INJECT ClassOrInterfaceBody : 
    import java.util.*;
{
    public String getAsString() {
        return getInnerText();
    }
    
    // REVISIT. fix token chaining
    public void prepend(List<ClassOrInterfaceBodyDeclaration> elements) {
        ListIterator<Node> iterator = iterator();
        Node n = null;
        while (iterator.hasNext()) {
            n = iterator.next();
              if (n instanceof Token) {
              Token t = (Token) n;
               if (t.getType() == TokenType.LBRACE) {
                   break;
               }
              }
        }
        for (ClassOrInterfaceBodyDeclaration elem : elements) {
            iterator.add(elem);
            iterator.next();
        }
    }
    
    // REVISIT. fix token chaining 
    public void removeDuplicateMethods() {
        Set<String> sigs = new HashSet<String>();
        ListIterator<Node> decls = iterator();
        while (decls.hasNext()) {
           Node n = decls.next();
           if (n instanceof ClassOrInterfaceBodyDeclaration) {
               ClassOrInterfaceBodyDeclaration decl = (ClassOrInterfaceBodyDeclaration) n;
               String sig = decl.getFullNameSignatureIfMethod();
               if (sig != null) {
                    if (sigs.contains(sig)) {
                        decls.remove();
                    } else {
                        sigs.add(sig);
                    }
               }
           }
        }
    }
}

INJECT ClassOrInterfaceBodyDeclaration : 
{
    public boolean isMethod() {
        return firstChildOfType(MethodDeclaration.class) != null;
    }
    
    public String getFullNameSignatureIfMethod() {
        MethodDeclaration md = firstChildOfType(MethodDeclaration.class);
        return md == null ? null : md.getFullSignature();
    }
}

INJECT FieldDeclaration : 
   import java.util.*;
   extends ClassOrInterfaceBodyDeclaration
{

  /**
   * @return the Identifier nodes that correspond to the 
   *          declaration of an instance variable. 
   */
  public List<Identifier> getVariableIds() {
     return descendants(Identifier.class, FieldDeclaration::isVariableDeclarator);
  }

  static boolean isVariableDeclarator(Identifier id) {
      Node parent = id.getParent();
      return parent instanceof VariableDeclaratorId || 
             parent instanceof VariableDeclarator ||
             parent instanceof FieldDeclaration;
  }
}


INJECT PARSER_CLASS : {

    private EnumSet<TokenType> javaccKeyWords = EnumSet.of(_INJECT,
       _INCLUDE, _LOOKAHEAD, _FAIL, _ENSURE, _SCAN, _IGNORE_CASE, _NO_NFA, 
       _PARSER_BEGIN, _PARSER_END, _TOKEN, _SPECIAL_TOKEN, _MORE,
       _SKIP, _TOKEN_MGR_DECLS, _ATTEMPT, _RECOVER, _ON_ERROR, _UPTO, 
       _LEXICAL_STATE, _EOF);


    private Token TOKEN_HOOK(Token tok) {
        TokenType type = tok.getType();
        if ((type == RSIGNEDSHIFT || type == RUNSIGNEDSHIFT) && !isInProduction("Expression")) {
          Token gt = Token.split(tok, 1, GT, GT);
          if (type == RUNSIGNEDSHIFT) {
              Token.split(gt.getNextToken(), 1, GT, GT);
          }
          return gt;
        } 
        return tok;
    }

    private Token TOKEN_HOOK(Token t) {
        if (javaccKeyWords.contains(t.getType())) {
            if (isInProduction("CompilationUnit", "ClassOrInterfaceBody", "BlockStatement", "TreeBuildingAnnotation")) {
               if (t.getType() != _PARSER_END || !isInProduction("ParserCodeDecls")) {
                   Token id = Token.newToken(IDENTIFIER, t.getImage(), this);
                   id.copyLocationInfo(t);
                   return id;
               }
           }
        }
        t.setGrammar(getGrammar());
        return t;
    }
}

INJECT CaseStatement :
{
    // If the case statement has an unreachable break statement at the
    // end, we remove it. This allows us to get rid of this horrid longstanding kludge
    // This is no longer used! I leave it here for historical reasons! 
    // See: https://parsers.org/t/a-fun-example-of-code-injection-at-work/30
    public void close() {
        if (getChildCount() >= 2) {
            Node last = this.getLastChild();
            Node secondLast = this.getChild(getChildCount() -2);
            if ((last instanceof BreakStatement) && (secondLast instanceof ReturnStatement)) {
                removeChild(last);
            }
        }
    }
}

INJECT MethodDeclaration : 
{
    public String getName() {
        for (Node n : children) {
            if (n instanceof Identifier) {
                return n.toString();
            }
        }
        throw new IllegalStateException();
    }
    
    public FormalParameters getFormalParameters() {
        return firstChildOfType(FormalParameters.class);
    }
    
    public String getFullSignature() {
        return getName() + getFormalParameters();
    }
}

INJECT ThrowsList : 
    import java.util.List;
    import java.util.ArrayList;
{
    public List<Node> getTypes() {
        List<Node> result = new ArrayList<>();
        for (Node n : children) {
           if ((n instanceof Name) || (n instanceof Identifier)) {
              result.add(n);
           }
        }
        return result; 
    }
}

INJECT Identifier : 
{
    private String tokenHookName, openHookName, closeHookName;

   public String getNormalizedText() {
        String image = getImage();
        if (image.equals("jjtThis") || image.equals("CURRENT_NODE")) { 
            return getGrammar().getCurrentNodeVariableName();
        }
        if (image.equals("PARSER_CLASS")) {
            return getGrammar().getParserClassName();
        }
        if (image.equals("LEXER_CLASS")) {
            return getGrammar().getLexerClassName();
        }
        if (image.equals("CONSTANTS_CLASS")) {
            return getGrammar().getConstantsClassName();
        }
        if (image.equals("NODE_PACKAGE")) {
            return getGrammar().getNodePackage();
        }
        if (image.equals("PARSER_PACKAGE")) {
            return getGrammar().getParserPackage();
        }
        if (image.equals("current_token")) {
            return "lastConsumedToken";
        }
        if (image.equals("TOKEN_HOOK")) {
            if (tokenHookName ==null) {
                tokenHookName = getGrammar().generateUniqueIdentifier("tokenHook$", this);
            }
            return tokenHookName;
        }
        if (image.equals("OPEN_NODE_HOOK")) {
            if (openHookName == null) {
                openHookName = getGrammar().generateUniqueIdentifier("openNodeHook$", this);
            }
            return openHookName;
        }
        if (image.equals("CLOSE_NODE_HOOK")) {
            if (closeHookName == null) {
                closeHookName = getGrammar().generateUniqueIdentifier("closeNodeHook$", this);
            }
            return closeHookName;
        }
        return image;
   }
}

INJECT interface Node :
   import com.javacc.Grammar;
{
   Grammar getGrammar();
   void setGrammar(Grammar grammar);
}


INJECT Token :
    import com.javacc.Grammar;
{
    private Grammar grammar;

    public Grammar getGrammar() {
        if (grammar == null) {
           if (parent != null) {
              grammar = parent.getGrammar();
           }
        }
        return grammar;
    }

    public void setGrammar(Grammar grammar) {
         this.grammar = grammar;
    }
    
    public String getNodeName() {
        return getType().toString();
    }
    
    public String getLeadingComments() {
        Token specialToken = getPreviousToken() == null || !getPreviousToken().isUnparsed() ? null : getPreviousToken();
        if (specialToken == null)
            return "";
        StringBuilder buf = new StringBuilder();
        Token tok = specialToken;
        while (tok.getPreviousToken() != null && tok.getPreviousToken().isUnparsed()) {
            tok = tok.getPreviousToken();
        }
        while (tok != this && tok != null) {
            buf.append(tok);
            tok = tok.getNext();
        }
        return buf.toString();
    }
    
    public String getNormalizedText() {
        return image;
    }
}

#Root throws IOException #GrammarFile :
{
    TokenManagerDecls decls;
    TokenProduction tp;
}
{
   [
      OptionsBlock | Options
   ]!
   [ParserCodeDecls]
   (
      SCAN 1 {!grammar.getUserDefinedLexer()} =>
      tp=TokenProduction  {grammar.addTokenProduction(tp);}
      |
      decls=TokenManagerDecls {grammar.addCodeInjection(decls);}
      |
      CodeInjection2 
      |
      CodeInjection
      |
      BNFProduction
      |
      GrammarInclusion
  )+!
  <EOF>
  {
        return CURRENT_NODE;
  }
}

ParserCodeDecls : 
{
    Token id;
    CompilationUnit parserCode;
}
{
   "PARSER_BEGIN"
   "("
   id=<IDENTIFIER>
   ")"
   {
      if (!grammar.isInInclude())
          grammar.setParserClassName(id.getImage());
   }
   parserCode=CompilationUnit
   {
       if (!grammar.isInInclude())
           grammar.setParserCode(parserCode);
   }
   "PARSER_END" ["(" <IDENTIFIER> ")"]
}

INJECT ReturnType :
    import java.util.List;
{
    public boolean getAsBoolean() {
        List<Token> lt = getRealTokens();
        return lt.size() != 1 || lt.get(0).getType() != VOID;
    }
}

INJECT PARSER_CLASS : {
    private boolean enterIncludes = true, isAlias = false;
    public void setEnterIncludes(boolean enterIncludes) {this.enterIncludes = enterIncludes;}
}

GrammarInclusion throws IOException :
{
   List<String> locations = new ArrayList<>();
   Token includeToken;
}
   <_INCLUDE> {includeToken = lastConsumedToken;}
   (
       (
           <STRING_LITERAL> {locations.add(((StringLiteral)lastConsumedToken).getString());}
           |
           <IDENTIFIER> {locations.add(lastConsumedToken.getImage());}
       )
       (
         "!" 
         (<STRING_LITERAL>|<IDENTIFIER>)
         {
           if (lastConsumedToken instanceof StringLiteral) {
              locations.add(((StringLiteral) lastConsumedToken).getString());
           } else {
               locations.add(lastConsumedToken.getImage());
           }
         }
       )*
       |
       "(" <STRING_LITERAL> {locations.add(((StringLiteral)lastConsumedToken).getString());} ")" 
   )
   [";"]
   {
      if (enterIncludes) {
          Node included = grammar.include(locations, includeToken);
          if (included!=null) {
              CURRENT_NODE.addChild(included);
          } else {
              grammar.addWarning(CURRENT_NODE, "File is already included.");
          }
      }
   }
;

CodeInjection :
{
    boolean isInterface = false;
    Annotation annotation = null;
    boolean foundOptionalInitialBrace = false;
    boolean usingParentheses = false;
    ImportDeclaration id;
    ObjectType ot;
    Annotation ann;
    ClassOrInterfaceBody coib;
}   
        "INJECT" ["(" {usingParentheses = true;}]
        [
            "class"
            |
            "interface" {isInterface = true;}
        ]
        <IDENTIFIER> {CURRENT_NODE.name = lastConsumedToken.toString();} 
        [
            SCAN {usingParentheses} => ")"
        ]
        ":"
        [
          SCAN "{" ("}" | "import" | "extends" | "implements" | (Annotation)* "}") => "{"
          {foundOptionalInitialBrace=true;}
        ]
        (
            id=ImportDeclaration {CURRENT_NODE.importDeclarations.add(id);}
        )*
        (
            ann=Annotation {CURRENT_NODE.annotations.add(ann);}
        )*
        [
             "extends" 
             ot=ObjectType {CURRENT_NODE.addExtendsType(ot);}
             (SCAN {isInterface} => "," ot=ObjectType {CURRENT_NODE.addExtendsType(ot);})*
             [";"]
        ]
        [
             SCAN {!isInterface} =>
             "implements" ot=ObjectType {CURRENT_NODE.addImplementsType(ot);}
             ("," ot=ObjectType {CURRENT_NODE.addImplementsType(ot);})*
             [";"]
        ]
        [
           SCAN 0 {foundOptionalInitialBrace} => "}"
        ]
        [coib=ClassOrInterfaceBody {CURRENT_NODE.body = coib;}]
        {
                if (enterIncludes) {
                    grammar.addCodeInjection(CURRENT_NODE);
                }
        }
;

INJECT CodeInjection : 
   import java.util.List;
   import java.util.ArrayList;
{
   public String name;
   public List<ImportDeclaration> importDeclarations = new ArrayList<ImportDeclaration>();
   public List<Annotation> annotations = new ArrayList<>();
   public List<ObjectType> extendsList = new ArrayList<>();
   public List<ObjectType> implementsList = new ArrayList<>();
   public ClassOrInterfaceBody body;
   public boolean isInterface;   

   public void addExtendsType(ObjectType type) {extendsList.add(type);}
   public void addImplementsType(ObjectType type) {implementsList.add(type);}
}

CodeInjection2 :
{
        CompilationUnit jcu;
}
        <_INJECT>
        ":" =>|| "{"
        jcu=CompilationUnit
       "}"
        {
                if (enterIncludes) {
                    grammar.addCodeInjection(jcu);
                }
        }
;

Options #Options :
    {HashMap<String, Object> settings = new HashMap<>();} 
    Setting(settings) =>||
    (Setting(settings))*
    {grammar.setSettings(settings);}
;

OptionsBlock #Options :
    {Map<String, Object> settings = new HashMap<>();} 
    <IDENTIFIER> 
    [
        SCAN {!getToken(0).getImage().equalsIgnoreCase("options")}#
        => FAIL "Expecting \"options\" here"
    ]
    =>||
    [":"]
    "{" 
    ( Setting (settings) )*! "}"
    {grammar.setSettings(settings);}
;

Setting(Map<String,Object> settings) #Setting :
{
      String key;
      Token name;
      Object value = Boolean.TRUE;
}
  ( 
     name = <IDENTIFIER> 
     | 
     name = <_IGNORE_CASE>
     |
     name = <_DEACTIVATE_TOKENS>
  )
  =>|+1
  {
      key = name.getImage().toUpperCase();
  }
  [
     "="
     (
        "true" {value=true;}
        |
        "false" {value=false;}
        |
        <INTEGER_LITERAL> {value = ((IntegerLiteral) lastConsumedToken).getValue();}
        |
        <STRING_LITERAL> {value = ((StringLiteral) lastConsumedToken).getString();}
        |
        SCAN <IDENTIFIER> "."
        =>Name {value = peekNode().toString();}
        |
        <IDENTIFIER> {value = lastConsumedToken.getImage();} 
           ("," {value+=",";} <IDENTIFIER> {value+=lastConsumedToken.getImage();})* 
     )
  ]  
  ";"
  {
      settings.put(key, value);
  }
;

BNFProduction :
{
    TreeBuildingAnnotation tba = null;
    Token firstToken=getToken(1), id;
    Expansion exp;
}
    [
        "public" | "private" | "protected"
    ]
    [
       SCAN ReturnType <IDENTIFIER> => ReturnType
       |
       "#" {CURRENT_NODE.setImplicitReturnType(true);}
    ]
    id=<IDENTIFIER> {CURRENT_NODE.setName(id.getImage());}
    [FormalParameters]
    [
      ThrowsList
    ]
    [
        tba=TreeNodeDescriptor 
        {
            String nodeName = tba.getNodeName();
            if (nodeName == null) nodeName = CURRENT_NODE.getNodeName();
            grammar.addNodeType(CURRENT_NODE.getName(), nodeName);
        }
    ]
    [
        "RECOVER_TO" ExpansionChoice
        {CURRENT_NODE.setRecoveryExpansion((Expansion)peekNode());} 
    ]
    ":"
    [
        SCAN 2 => <IDENTIFIER> 
        {CURRENT_NODE.setLexicalState(lastConsumedToken.getImage());}
        ":"
    ]
    (
        // Older syntax
        => [=>Block] "{" ExpansionChoice {CURRENT_NODE.setExpansion((Expansion) peekNode());} "}"
        |
        [Block {CodeBlock block = (CodeBlock) peekNode();}
          ["#" {block.setAppliesInLookahead(true);}]
        ]
        ExpansionChoice 
        {CURRENT_NODE.setExpansion((Expansion) peekNode());} ";"
    )
    {
        CURRENT_NODE.adjustFirstToken(firstToken);
        if (tba == null && !grammar.getNodeDefaultVoid()) {
           grammar.addNodeType(CURRENT_NODE.getName(),CURRENT_NODE.getName());
        }
     }
;

INJECT BNFProduction : 
    import java.util.*;
    import com.javacc.core.TokenSet;
    import com.javacc.core.Expansion;
{
    @Property boolean implicitReturnType;

    /**
     * The lexical state that this production
     * needs to be scanned in.
     */ 
    @Property String lexicalState;
//    public void CLOSE_NODE_HOOK() {} //FIXME

    public boolean getHasScanLimit() {
        return expansion instanceof ExpansionSequence && ((ExpansionSequence) expansion).getHasScanLimit();
    }

    public boolean getHasExplicitLookahead() {
        return expansion.getHasExplicitLookahead();
    }

    public Lookahead getLookahead() {
        return expansion.getLookahead();
    }

    public CodeBlock getJavaCode() {
       return firstChildOfType(CodeBlock.class);
    }
    
    public TreeBuildingAnnotation getTreeBuildingAnnotation() {
        return firstChildOfType(TreeBuildingAnnotation.class);
    }
    
    public String getNodeName() {
        TreeBuildingAnnotation tba = getTreeBuildingAnnotation();
        if (tba != null) {
             String nodeName = tba.getNodeName();
             if (nodeName != null && !nodeName.equals("abstract") 
                 && !nodeName.equals("interface")
                 && !nodeName.equals("void")) {
                return nodeName;
             }
        }
        return this.getName();
    }

    private String leadingComments="";

    @Property Expansion expansion, recoveryExpansion;
    @Property String name;

    public ThrowsList getThrowsList() {
        return firstChildOfType(ThrowsList.class);
    }
    
    public FormalParameters getParameterList() {
        return firstChildOfType(FormalParameters.class);
    }
    
    public TreeBuildingAnnotation getTreeNodeBehavior() {
        return firstChildOfType(TreeBuildingAnnotation.class);
    }


    /**
     * The NonTerminal nodes which refer to this production.
     */
    private List<NonTerminal> referringNonTerminals;
    
    public List<NonTerminal> getReferringNonTerminals() {
        if (referringNonTerminals == null) {
           referringNonTerminals = getGrammar().descendants(NonTerminal.class, nt->nt.getName().equals(name));
        }
        return referringNonTerminals;
    }

    public String getLookaheadMethodName() {
        return "check$" + name;
    }

    /**
     * Can this production be matched by an empty string?
     */
    public boolean isPossiblyEmpty() {
         return getExpansion().isPossiblyEmpty();
    }

    public boolean isAlwaysSuccessful() {
        return getExpansion().isAlwaysSuccessful();
    }

    public String getAccessModifier() {
        for (Token t : childrenOfType(Token.class)) {
           TokenType type = t.getType();
           if (type == PRIVATE) {
               return "private";
           }
           else if (type == PROTECTED) {
               return "protected";
           }
           else if (type == PACKAGE) {
               return "";
           }
        }
        return "public";
    }

    public String getReturnType() {
        if (isImplicitReturnType()) {
            return getNodeName();
        }
        ReturnType rt = firstChildOfType(ReturnType.class);
        return rt == null ? "void" : rt.getAsString();
    }
    
    public void adjustFirstToken(Token t) {
        //FIXME later. Not very urgent.
/*        
        Token firstToken = firstChildOfType(Token.class);
        if (firstToken != t) {

        }
        if (firstChildOfType(Token.class) !== t)
        this.leadingComments = t.getLeadingComments();
*/
    }

    public String getLeadingComments() {
        return leadingComments;
    }
    
    private TokenSet firstSet, finalSet;
    
    public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet = getExpansion().getFirstSet();
        }
        return firstSet;
    }

    public String getFirstSetVarName() {
        return getName() + "_FIRST_SET";
    }
    
    public TokenSet getFinalSet() {
          if (finalSet == null) {
              finalSet = getExpansion().getFinalSet();
          }
          return finalSet;
    }
    
    public boolean isConcrete() {
       return getExpansion().isConcrete();
    }
}

TreeNodeDescriptor #TreeBuildingAnnotation :
  "#" [<IDENTIFIER>|"abstract"|"interface"|"void"]
   [
       "("
          [
            ">"
          ]
          Expression()
       ")"
  ]
;

INJECT TreeBuildingAnnotation :
{
    /**
     * Just returns whatever comes after the hash ("#") including "void", etc.
     */
    public String getNodeName() {
        Token hash = firstChildOfType(TokenType.HASH);
        if (hash == null) return null;
        Token nextToken = hash.getNext();
        TokenType nextType = nextToken.getType();
        if (nextType != IDENTIFIER 
            && nextType != ABSTRACT 
            && nextType != INTERFACE 
            && nextType != VOID) return null;
        return nextToken.getImage();
    }

    public boolean isNeverInstantiated() {
        return isVoid() || isAbstract() || isInterface();
    }

    public Expression getCondition() {
        return firstChildOfType(Expression.class);
    }
    
    public boolean getGtNode() {
        return firstChildOfType(GT) != null;
    }

    public boolean isAbstract() {
        return "abstract".equals(getNodeName());
    }

    public boolean isInterface() {
        return "interface".equals(getNodeName());
    }
    
    public boolean isVoid() {
        return "void".equals(getNodeName());
    }
}


TokenProduction #TokenProduction :
{
    Token t = null;
    String tokenClassName = null;
    String firstSpecifiedLexicalState = null;
    boolean multipleStatesSpecified = false, useBraces = false, noNfa = false;;
    boolean ignoreCase = false;
}
  [
    => "<" "*" ">" {multipleStatesSpecified = true;} 
    |
    "<"
      <IDENTIFIER>{
          firstSpecifiedLexicalState = lastConsumedToken.getImage();
          grammar.addLexicalState(firstSpecifiedLexicalState);
      }
      ("," <IDENTIFIER> {multipleStatesSpecified = true; grammar.addLexicalState(lastConsumedToken.getImage());})*
    ">"
  ]
  (<_TOKEN> | <_SPECIAL_TOKEN> | <_MORE> | "SKIP")
  [
    "[" ("IGNORE_CASE" {ignoreCase = true;} | "NO_NFA" {noNfa=true;})"]"
  ]
  ["#" t = <IDENTIFIER> {tokenClassName=t.getImage();}] 
  ":"
  ["{" {useBraces = true;}]
   RegexpSpec(CURRENT_NODE, tokenClassName, noNfa)
   ( "|" RegexpSpec(CURRENT_NODE, tokenClassName, noNfa) )*
   (
      SCAN {useBraces} => "}" 
      | 
      ";"
   )
   {
      if (!multipleStatesSpecified) {
          if (firstSpecifiedLexicalState == null) {
              firstSpecifiedLexicalState = grammar.getDefaultLexicalState();
          }
          CURRENT_NODE.setImplicitLexicalState(firstSpecifiedLexicalState);
      }
      CURRENT_NODE.setIgnoreCase(ignoreCase || grammar.isIgnoreCase());
      CURRENT_NODE.setNoNfa(noNfa);
   }
;

INJECT TokenProduction :
    import java.util.*;
    import com.javacc.core.LexerData;
    import com.javacc.core.LexicalStateData;
{
   @Property private boolean explicit=true, ignoreCase, noNfa;

    private String implicitLexicalState;
    
    public void setImplicitLexicalState(String implicitLexicalState) {
        this.implicitLexicalState = implicitLexicalState;
    }

    public List<RegexpSpec> getRegexpSpecs() {
        return childrenOfType(RegexpSpec.class);
    }

    /**
     * The states in which this regular expression production exists.
     */
    public String[] getLexicalStateNames() {
    
        if (implicitLexicalState != null) {
            return new String[] {implicitLexicalState};
        }        
        if (isInAllLexStates()) {
             return getGrammar().getLexicalStates();
        }
        Set<String> states = new LinkedHashSet<String>();
        for (Token t : childrenOfType(Token.class)) {
            if (t.getType() == HASH) break;
            if (t.getType() == IDENTIFIER) {
                states.add(t.getImage());
            }
        }
        if (states.isEmpty()) {
           return new String[] {getGrammar().getDefaultLexicalState()};
        }
        String[] lexStates = new String[states.size()];
        int i=0;
        for (String s : states) {
           lexStates[i++] = s;
        } 
        return lexStates;
    }
    
    private boolean isInAllLexStates() {
       for (Node n : children) {
          if (n instanceof Token) {
          Token t = (Token) n;
              if (t.getType() == STAR) {
                  return true;
              }
          }
       }
       return false;
    }

    public String getKind() {
       for (Token t : childrenOfType(Token.class)) {
           switch (t.getType()) {
              case _MORE : return "MORE";
              case _SPECIAL_TOKEN : return "UNPARSED";
              case _SKIP : return "SKIP";
              case _TOKEN : return "TOKEN";
              default: 
           }
      }
      return "TOKEN";
    }
}

TokenManagerDecls :
   "TOKEN_MGR_DECLS" ":"
    ClassOrInterfaceBody
;

RegexpSpec(TokenProduction p, String tokenClassName, boolean noNfa) #RegexpSpec :
{
    RegularExpression regexp;
}
  RegexpExpansion(noNfa)
  {
      regexp = (RegularExpression) peekNode();
      CURRENT_NODE.addChild(popNode());
      if (tokenClassName != null) {
          regexp.setGeneratedClassName(tokenClassName);
      }
  }
  [
     "#"<IDENTIFIER>
     {
        regexp.setGeneratedSuperClassName(tokenClassName);
        regexp.setGeneratedClassName(lastConsumedToken.getImage());
     }
  ]
  [
      SCAN {!regexp.isPrivate()} \...\TokenProduction =>
      Block
  ]
  [ 
      SCAN {!regexp.isPrivate()} \...\TokenProduction =>
      ":" <IDENTIFIER>
  ]
;

INJECT RegexpSpec : 
   import com.javacc.core.RegularExpression;
{
    public String getNextState() {
        Token nsTok = getNsTok();
        return nsTok == null ? null : nsTok.toString();
    }

    public Token getNsTok() {
        Token colon = firstChildOfType(COLON);
        return colon == null ? null : colon.getNext();
    }

    public RegularExpression getRegexp() {
         return firstChildOfType(RegularExpression.class);
    }

    public CodeBlock getCodeSnippet() {
        return firstChildOfType(CodeBlock.class);
    }
}

ExpansionChoice : 
  ExpansionSequence
  ( "|" ExpansionSequence)*
;

INJECT ExpansionChoice : 
   import com.javacc.core.Expansion;
   import com.javacc.core.TokenSet;
   import java.util.List;
   extends Expansion 
{
   public List<Expansion> getChoices() {
       return childrenOfType(Expansion.class);
   }
   
   public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet = new TokenSet(getGrammar());
           for (Expansion choice : getChoices()) {
               firstSet.or(choice.getLookaheadExpansion().getFirstSet());
           }
        }
        return firstSet;
   }
   
   public TokenSet getFinalSet() {
       TokenSet finalSet = new TokenSet(getGrammar());
       for (Expansion choice : getChoices()) {
           finalSet.or(choice.getFinalSet());
       }
       return finalSet;
   }
   
   
   public boolean isPossiblyEmpty() {
        for (Expansion e : getChoices()) {
            if (e.isPossiblyEmpty()) {
                return true;
            }
        }
        return false;
   }

   public boolean isAlwaysSuccessful() {
       if (!super.isAlwaysSuccessful()) return false;
       for (Expansion choice : getChoices()) {
           if (choice.isAlwaysSuccessful()) return true;
       }
       return false;
   }
   
   public int getMinimumSize() {
       int result = Integer.MAX_VALUE;
       for (Expansion choice : getChoices()) {
          int choiceMin = choice.getMinimumSize();
          if (choiceMin ==0) return 0;
          result = Math.min(result, choiceMin);
       }
       return result;
   }

   public int getMaximumSize() {
       int result = 0;
       for (Expansion exp : getChoices()) {
           result = Math.max(result, exp.getMaximumSize());
           if (result == Integer.MAX_VALUE) break;
       }
       return result;
   }
   
   public boolean isConcrete() {return false;} 
   
   public boolean getSpecifiesLexicalStateSwitch() {
       for (Expansion choice : getChoices()) {
           if (choice.getSpecifiesLexicalStateSwitch()) return true;
       }
       return false;
   }

}

ExpansionWithParentheses :
{
    Token lparen = null;
    LexicalStateSwitch lss=null;
}
   [lss=LexicalStateSwitch]
   lparen ="(" =>|| ExpansionChoice {Expansion nested = (Expansion) peekNode();} ")"
   [
       "*" {CURRENT_NODE = new ZeroOrMore();}
       |
       "?" {CURRENT_NODE = new ZeroOrOne();}
       |
       "+" {CURRENT_NODE = new OneOrMore();}
   ]
   [
       SCAN ~\...\Lookahead => 
       "!" 
       {
           if (CURRENT_NODE instanceof ZeroOrOne) {
               nested.setTolerantParsing(true);
           } else {
               CURRENT_NODE.setTolerantParsing(true);
           }
       }
   ]
   [UpToHere(CURRENT_NODE)]
   {
       Node startNode = lss != null ? lss : lparen;
       CURRENT_NODE.copyLocationInfo(startNode, lastConsumedToken);
   }
;


INJECT ExpansionWithParentheses : 
   import com.javacc.core.TokenSet;
   import com.javacc.core.Expansion;
   extends Expansion
{
    public boolean isConcrete() {return getNestedExpansion().isConcrete();}
    public int getMaximumSize() {return getNestedExpansion().getMaximumSize();}
    public int getMinimumSize() {return getNestedExpansion().getMinimumSize();}
    public boolean isPossiblyEmpty() {return getNestedExpansion().isPossiblyEmpty();}
    public boolean isAlwaysSuccessful() {return getNestedExpansion().isAlwaysSuccessful();}
    public TokenSet getFirstSet() {return getNestedExpansion().getFirstSet();}
    public TokenSet getFinalSet() {return getNestedExpansion().getFinalSet();}
    public boolean getSpecifiesLexicalStateSwitch() {
        return getSpecifiedLexicalState() != null || getNestedExpansion().getSpecifiesLexicalStateSwitch();
    }


    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }

    public String getSpecifiedLexicalState() {
        LexicalStateSwitch lss = firstChildOfType(LexicalStateSwitch.class);
        return lss == null ? super.getSpecifiedLexicalState() : lss.getLexicalStateName();
    }
}

ExpansionSequence# :
{
   Expansion sub;
   Lookahead la = null;
}
  [ 
    SCAN ~\...\Lookahead 
    =>
    la=Lookahead
    {
       la.setExpansion(CURRENT_NODE);
       CURRENT_NODE.setLookahead(la);
     }
  ]
  (
     => sub=ExpansionUnit
     {
         pokeNode(sub);
     }
  )+!
;

INJECT ExpansionSequence : 
   import com.javacc.Grammar;
   import com.javacc.core.Expansion;
   import com.javacc.core.TokenSet;
   import java.util.*;
   extends Expansion;
{
    public List<Expansion> getUnits() {
       return childrenOfType(Expansion.class);
    }

    /**
     * @return a List that includes child expansions that are 
     * inside of superfluous parentheses.
     */
    public List<Expansion> allUnits() {
        List<Expansion> result = new ArrayList<>();
        for (Expansion unit : getUnits()) {
            if (unit.superfluousParentheses()) {
                result.addAll(unit.firstChildOfType(ExpansionSequence.class).allUnits());
            }
            else result.add(unit);
        }
        return result;
    }

    public Expansion firstNonEmpty() {
        for (Expansion unit : getUnits()) {
            if (unit instanceof ExpansionWithParentheses && ((ExpansionWithParentheses)unit).superfluousParentheses()) {
                unit = unit.firstChildOfType(ExpansionSequence.class).firstNonEmpty();
                if (unit != null) return unit;
            }
            else if (!unit.isPossiblyEmpty()) return unit;
        }
        return null;
    }

    public boolean getSpecifiesLexicalStateSwitch() {
        for (Expansion unit : getUnits()) {
            if (unit.getSpecifiesLexicalStateSwitch()) return true;
            if (!unit.isPossiblyEmpty()) break;
        }
        return false;
    }

    public boolean isAlwaysSuccessful() {
       if (!super.isAlwaysSuccessful()) return false;
       for (Expansion unit : getUnits()) {
           if (!unit.isAlwaysSuccessful()) return false;
       }
       return true;
    }

    public TokenSet getFirstSet() {
       if (firstSet == null) {
           firstSet = new TokenSet(getGrammar());
           for (Expansion child : getUnits()) {
               firstSet.or(child.getFirstSet());
               if (!child.isPossiblyEmpty()) {
                  break;
               }
           }
       }
       return firstSet;
   }

   public TokenSet getFinalSet() {
       TokenSet finalSet = new TokenSet(getGrammar());
       List<Expansion> children = getUnits();
       Collections.reverse(children);
       for (Expansion child : children) {
           finalSet.or(child.getFinalSet());
           if (!child.isPossiblyEmpty()) {
              break;
           }
       }
       return finalSet;
   }

   public boolean getRequiresScanAhead() {
       boolean foundNonEmpty = false;
       for (Expansion unit : getUnits()) {
            if (unit.isScanLimit()) return true;
            if (!foundNonEmpty && (unit instanceof NonTerminal)) {
                NonTerminal nt = (NonTerminal) unit;
                if (nt.getHasScanLimit()) return true;
                if (nt.getProduction().getHasExplicitLookahead()) return true;
            }
            if (!unit.isPossiblyEmpty()) foundNonEmpty = true;
       }
       Lookahead la = getLookahead();
       return la != null && la.getRequiresScanAhead();
   }

   private Lookahead lookahead;

   public void setLookahead(Lookahead lookahead) {
        this.lookahead = lookahead;
   }

   public Lookahead getLookahead() {
       if (lookahead !=null) return lookahead;
       for (Expansion unit : allUnits()) {
           if (unit instanceof NonTerminal) {
               NonTerminal nt = (NonTerminal) unit;
               return nt.getNestedExpansion().getLookahead();
           }
           if (unit.getMaximumSize() >0) break;
       }
       return null;
    }

    public boolean getHasExplicitLookahead() {
        return lookahead!=null;
    }

   public boolean isPossiblyEmpty() {
        for (Expansion e : getUnits()) {
            if (!e.isPossiblyEmpty()) {
                return false;
            }
        }
        return true;
    }

    public int getMinimumSize() {
        int result = 0;
        for (Expansion unit : getUnits()) {
            int minUnit = unit.getMinimumSize();
            if (minUnit == Integer.MAX_VALUE) return Integer.MAX_VALUE;
            result += minUnit;
        }
        return result;
    }

    public int getMaximumSize() {
       int result = 0;
       for (Expansion exp : getUnits()) {
           int max = exp.getMaximumSize();
           if (max == Integer.MAX_VALUE) return Integer.MAX_VALUE;
           result += max;
       }
       return result;
   }
   
   public boolean isConcrete() {
      for (Expansion exp : getUnits()) {
         if (!exp.isConcrete()) {
            return false;
         }
      }
      return true;
   }

   /**
    * @return whether we have a scan limit, including an implicit one inside a nested NonTerminal
    */
   public boolean getHasScanLimit() {
       boolean atStart = true;
       for (Expansion unit : allUnits()) {
           if (unit.isScanLimit()) return true;
           if (atStart && unit instanceof NonTerminal) {
               if (unit.getHasScanLimit()) return true;
           }
           if (!unit.isPossiblyEmpty()) atStart = false;
       }
       return false;
   }

   /**
    * @return whether we have an <em>explicit</em> scan limit,
    * i.e. <em>not including</em> one that is inside a NonTerminal expansion.
    */
   public boolean getHasExplicitScanLimit() {
       for (Expansion unit : getUnits()) {
           if (unit.isScanLimit()) {
               return true;
           }
       }
       return false;
   }
}

Lookahead Lookahead #void :
(<RIGHT_ARROW>#Lookahead | ScanAhead | LegacyLookahead) 
{
    return (Lookahead) peekNode();
};

INJECT Assertion : 
   import com.javacc.core.Expansion;
   import com.javacc.core.TokenSet;
   extends Expansion 
{
    @Property String message = "Assertion failed";
    @Property Expression semanticLookahead;
    @Property LookBehind lookBehind;
    @Property Expansion expansion;
    @Property boolean expansionNegated, semanticLookaheadNested;

    public boolean getRequiresScanAhead() {
        return false;
    }
    
    public boolean isPossiblyEmpty() {
        return true;
    }
    
    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}
    
    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}
     
    public int getMinimumSize() {return 0;}

    public int getMaximumSize() {return 0;}

    public boolean isConcrete() {return false;}
}


Assertion :
   {
       Expression exp = null;
       LookBehind lb = null;
       Expansion expansion = null;
       Token messageToken;
   }
   "ASSERT"
   [
    "{" 
    exp=Expression {CURRENT_NODE.setSemanticLookahead(exp);}
    "}"
    ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
   ]  
   [=>LookBehind {lb = (LookBehind) peekNode(); CURRENT_NODE.setLookBehind(lb);}]
   [
       ["~" {CURRENT_NODE.setExpansionNegated(true);}] 
       ExpansionChoice {expansion = (Expansion) peekNode(); CURRENT_NODE.setExpansion(expansion);}
   ]
   [
       SCAN {exp == null && lb == null && expansion == null}
       => FAIL "Assertion is empty!"
   ]
   ":" 
   <STRING_LITERAL> 
   {
       String message = ((StringLiteral) lastConsumedToken).getString();
       CURRENT_NODE.setMessage(message);
   }
;

ScanAhead #Lookahead : 
{
   Token amountToken=null;
   boolean hasSemanticLookahead = false, getHasExplicitNumericalLookahead=false;
   Expansion expansion = null, upToExpansion = null;
   Expression exp=null;
   Node lb = null;
}
[=>exp=PrimaryExpression "=" {CURRENT_NODE.setLHS(exp);}]
<_SCAN>
[
    <INTEGER_LITERAL> {getHasExplicitNumericalLookahead = true;}
]
[
    "{" 
    exp=Expression {hasSemanticLookahead = true; CURRENT_NODE.setSemanticLookahead(exp);}
    "}"
    ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
]
/*
[
   <_UPTO> 
   ExpansionChoice 
   {
       upToExpansion = (Expansion) peekNode();
       CURRENT_NODE.setUpToExpansion(upToExpansion);
   }
]*/
[SCAN LookBehind {lb = peekNode();}]
[
    SCAN {!getHasExplicitNumericalLookahead} => 
    ["~" {CURRENT_NODE.setNegated(true);}] 
    ExpansionChoice {expansion = (Expansion) peekNode();}
    <RIGHT_ARROW>
    {
       CURRENT_NODE.setNestedExpansion(expansion);
    }
]
(
    SCAN {expansion == null} => <RIGHT_ARROW>
    |
    SCAN {expansion != null || (exp ==null && lb == null && upToExpansion == null)} => {}
)
;

LookBehind : 
   [<TILDE> {CURRENT_NODE.setNegated(true);}] 
   (LookBehindForward | LookBehindBackward)
;

LookBehindForward #void :
   (
       <SLASH>
       (
         ([<TILDE>]<IDENTIFIER>)
         |
         (<DOT>|<VAR_ARGS>)
       )
   )+
   [<BACKSLASH>]
;

LookBehindBackward #void :
   (
       <BACKSLASH>
       (
          ([<TILDE>]<IDENTIFIER>)
          |
          (<DOT>|<VAR_ARGS>)
       )
   )+
   [<SLASH>]
;

INJECT LookBehind :
import java.util.*;
{
    @Property boolean negated;

    public boolean isBackward() {
        return getChild(0) instanceof Backslash || getChild(1) instanceof Backslash;
    }

    public boolean getHasFinalEllipsis() {
        Token t = (Token) getChild(getChildCount() -1);
        return t.getImage().equals("...");
    }

    public List<String> getPath() {
        ArrayList<String> result = new ArrayList<>();
        boolean negated = false;
        for (Token t : childrenOfType(Token.class)) {
            String img = t.getImage();
            if (img.charAt(0) == '\\' || img.charAt(0)=='/') continue;
            if (img.equals("~")) {
                negated = true;
                continue;
            }
            if (negated) {
                result.add("~" + img);
            } else {
               result.add(img);
            }
            negated = false;
        }
        if (result.get(0).equals("~")) {
            result.remove(0);
        }
        return result;
    }

    public boolean getHasEndingSlash() {
        Token lastToken = (Token) getChild(getChildCount()-1);
        String img = lastToken.getImage();
        return img.equals("\\") || img.equals("/");
    }

    private String routineName;
    
    public String getRoutineName() {
        if (routineName == null) {
            routineName = getGrammar().generateUniqueIdentifier("backscan$", this);
        }
        return routineName;
    }
}

INJECT LegacyLookahead : extends Lookahead;

LegacyLookahead# :
{
    Expansion expansion = null;
    Expression exp = null;
    boolean empty = true, commaAtEnd = false;
}
{
  <_LOOKAHEAD>
  [
   "(" 
      [
        <INTEGER_LITERAL> {empty = false;}
      ]
      [ 
        SCAN {!empty} ~<RPAREN> 
        => "," {commaAtEnd = true;}
      ]
      [ 
        SCAN {empty} ~<RPAREN>|<LBRACE> 
        =>
        ["~" {CURRENT_NODE.setNegated(true);}] 
        ExpansionChoice
        {
           expansion = (Expansion) peekNode();
           CURRENT_NODE.setNestedExpansion(expansion);
           empty = false; commaAtEnd = false;
        }
      ]
      [ 
        SCAN {!empty && !commaAtEnd} ~")" => ","
      ]
      [
        "{"  exp=Expression  "}" {CURRENT_NODE.setSemanticLookahead(exp);}
        ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
      ]
     ")"
  ]
}

INJECT Lookahead :
   import com.javacc.core.Expansion;
   import com.javacc.core.RegularExpression;
   import com.javacc.core.TokenSet;
{
    @Property Expression LHS;
    @Property Expansion expansion, nestedExpansion, upToExpansion;
    @Property boolean negated, semanticLookaheadNested;
    @Property Expression semanticLookahead;

    private int amount=Integer.MAX_VALUE;

    public boolean isAlwaysSuccessful() {
        return !hasSemanticLookahead() && (getAmount() == 0 || getLookaheadExpansion().isPossiblyEmpty()); 
    }

    public boolean getRequiresScanAhead() {
        return !getLookaheadExpansion().isPossiblyEmpty() || isSemanticLookaheadNested();
//        return !getLookaheadExpansion().isPossiblyEmpty() && getAmount() > 1;
//          return !isAlwaysSuccessful() && getAmount() >1;
    }

    public boolean hasSemanticLookahead() {
        return getSemanticLookahead() != null;
    }
    
    public Expansion getLookaheadExpansion() {
        Expansion result = getNestedExpansion();
        if (result != null) {
            return result;
        }
        return expansion;
    }

    public boolean getHasExplicitNumericalAmount() {
        return firstChildOfType(TokenType.INTEGER_LITERAL) != null;
    }

    public int getAmount() {
        IntegerLiteral it = firstChildOfType(IntegerLiteral.class);
        if (it!=null) return it.getValue();
        if (this instanceof LegacyLookahead) {
            if (getNestedExpansion() == null && hasSemanticLookahead()) return 0;
        }
        return Integer.MAX_VALUE;
    }

    public LookBehind getLookBehind() {
        return firstChildOfType(LookBehind.class);
    }
}

Expansion ExpansionUnit :
{
    Expression lhs=null;
    Expansion result=null;
    TreeBuildingAnnotation tba = null;
}
 (
  SCAN 1 ~\...\Lookahead => 
  result = Failure
  |
  SCAN 1 ~\...\Lookahead =>
  result=TokenTypeActivation
  |
  SCAN 1 ~\...\Lookahead =>
  result=Block ["#" {((CodeBlock)result).setAppliesInLookahead(true);}]
  |
  SCAN 1 ~\...\Lookahead =>
  result=AttemptBlock
  |
  SCAN 1 ~\...\Lookahead =>
  result=TryBlock
  |
  SCAN 1 ~\...\Lookahead =>
  result = Assertion
  |
  result = ExpansionWithParentheses 
  |
  result = ZeroOrOne 
  |
  SCAN [PrimaryExpression "="] (<STRING_LITERAL>|"<")
  =>
  [
    SCAN ~\...\Lookahead PrimaryExpression "=" =>
    lhs=PrimaryExpression
    "="
  ]
  RegexpExpansion(false)
  {
      RegularExpression re = (RegularExpression) peekNode();
      result = re;
      re.setLHS(lhs);
      if (!(re instanceof EndOfFile)) {
            grammar.addInplaceRegexp(re);
      }
  }
  [UpToHere(result)]
  |
  SCAN [PrimaryExpression "="]<IDENTIFIER>
  => result=NonTerminal [UpToHere(result)]
  |
  FAIL
 )
 [
     SCAN 1 ~\...\Lookahead => 
    tba=TreeNodeDescriptor
 ]
 {
        result.setTreeNodeBehavior(tba);
        return result;
 }
;

#NonTerminal# :
  [
    => PrimaryExpression "="
  ]
  <IDENTIFIER>
  [
    SCAN "(" ExpansionSequence "|" => {}
    |
    SCAN "(" ExpansionChoice ")" ("*"|"+"|"?") => {}
    |
    InvocationArguments
  ]
  [
     SCAN ~\...\Lookahead =>
     "!"
     {CURRENT_NODE.setTolerantParsing(true);}
  ]
  {return CURRENT_NODE;}
;

UpToHere(Expansion exp) #void :
   SCAN ~\...\Lookahead =>
   <UP_TO_HERE>
   {
       String img = lastConsumedToken.getImage();
       exp.setScanLimit(true);
       int lastChar = img.codePointBefore(img.length());
       if (Character.isDigit(lastChar)) {
           exp.setScanLimitPlus(lastChar - '0');
       }
   }
;


INJECT NonTerminal : 
    import com.javacc.core.*;
    extends Expansion; 
{
    /**
     * The production this non-terminal corresponds to.
     */
    
    public BNFProduction getProduction() {
        return getGrammar().getProductionByName(getName());
    }

    public Expansion getNestedExpansion() {
        return getProduction().getExpansion();
    }

    public Lookahead getLookahead() {
        return getNestedExpansion().getLookahead();
    }

    public InvocationArguments getArgs() {
        return firstChildOfType(InvocationArguments.class);
    }

    public Expression getLHS() {
        return firstChildOfType(Expression.class);
    }
    
    public String getName() {
        return firstChildOfType(TokenType.IDENTIFIER).getImage();
    }
    
    /**
     * The basic logic of when we scan to the end of 
     * a NonTerminal, ignoring any nested lookahead or scan limits.
     */
    public boolean getScanToEnd() {
        if (isInsideLookahead()) return true;
        ExpansionSequence parent = (ExpansionSequence) getNonSuperfluousParent();
        if (!parent.isAtChoicePoint()) return true;
        if (parent.getHasExplicitNumericalLookahead() || parent.getHasExplicitScanLimit()) return true;
        return parent.firstNonEmpty() != this;
    }

    public TokenSet getFirstSet() {
        if (firstSet == null) {
            firstSet = getProduction().getExpansion().getFirstSet();
        }
        return firstSet;
     }
     private int reEntries;     
     public TokenSet getFinalSet() {
          ++reEntries;
          TokenSet result = reEntries == 1 ? getProduction().getExpansion().getFinalSet() : new TokenSet(getGrammar());
          --reEntries;
          return result;
     }
     
     public boolean isPossiblyEmpty() {
         return getProduction().isPossiblyEmpty();
     }

     public boolean isAlwaysSuccessful() {
         return getProduction().isAlwaysSuccessful();
     }
     
     // REVISIT. Is this disposition really correct?
     private boolean inMinimumSize, inMaximumSize;
     
     public int getMinimumSize() {
         if (inMinimumSize) return Integer.MAX_VALUE;
         inMinimumSize = true;
         int result = getProduction().getExpansion().getMinimumSize();
         inMinimumSize = false;
         return result;
     }

     public int getMaximumSize() {
         if (inMaximumSize) {
             return Integer.MAX_VALUE;
         }
         inMaximumSize = true;
         int result = getProduction().getExpansion().getMaximumSize(); 
         inMaximumSize = false;
         return result;
     }
     
     public boolean isConcrete() {
        return getProduction().isConcrete();
     }

     public boolean getHasScanLimit() {
         return getProduction().getHasScanLimit();
     }

     public boolean getSpecifiesLexicalStateSwitch() {
         return getNestedExpansion().getSpecifiesLexicalStateSwitch();
     }
}

//The following two productions are not actually used. These constructs are now 
// handled by ExpansionWithParentheses so the following two productions
// are not actually used. They have to be there so that the ZeroOrMore and
// OneOrMore types get defined. REVISIT. Need a way of defining Node subtypes
// without creating a dummy grammar rule for them.
ZeroOrMore : "(" ExpansionChoice ")" "*";
OneOrMore : "(" ExpansionChoice ")" "+"; 

//This production just matches the square bracket syntax. 
// The (...)? syntax is handled by ExpansionWithParentheses
ZeroOrOne : 
    [LexicalStateSwitch]
    "[" =>|| ExpansionChoice {Expansion exp = (Expansion) peekNode();} "]"
     ["!" {exp.setTolerantParsing(true);}]
     [UpToHere(CURRENT_NODE)]
;

INJECT ZeroOrOne : 
     import com.javacc.core.Expansion;
     import com.javacc.core.TokenSet;
     extends ExpansionWithParentheses 
{
    public boolean isAlwaysSuccessful() {return true;}
    public boolean isPossiblyEmpty() {return true;}
    public int getMinimumSize() {return 0;}
    public boolean isConcrete() {return false;}
}


INJECT ZeroOrMore : 
     import com.javacc.core.Expansion;
     import com.javacc.core.TokenSet;
     extends ExpansionWithParentheses 
{
    public boolean isPossiblyEmpty() {return true;}
    public boolean isAlwaysSuccessful() {return true;}
    public int getMinimumSize() {return 0;}
    public int getMaximumSize() {return Integer.MAX_VALUE;}
    public boolean isConcrete() {return false;}
}


INJECT OneOrMore : 
     import com.javacc.core.Expansion;
     import com.javacc.core.TokenSet;
     extends ExpansionWithParentheses 
{
     public int getMaximumSize() {return Integer.MAX_VALUE;}
     public boolean isConcrete() {return false;}
     public boolean isPossiblyEmpty() {return false;}
}


AttemptBlock : 
 "ATTEMPT" ExpansionChoice "RECOVER"  (ExpansionWithParentheses | Block)
;

INJECT AttemptBlock : 
   import java.util.List;
   import com.javacc.core.Expansion;
   import com.javacc.core.TokenSet;
   extends Expansion;
{
   public Expansion getNestedExpansion() {
       return firstChildOfType(Expansion.class);
   }
   
   public Expansion getRecoveryExpansion() {
       return (Expansion) getChild(3);
    }
   
    public boolean isPossiblyEmpty() {
        return getNestedExpansion().isPossiblyEmpty();
    }
    
    //REVISIT: Should this take RECOVER into account? I don't think so,
    // but I still have to think about it a bit more.
    public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet=getNestedExpansion().getFirstSet();
        }
        return firstSet;
    }
   
   
    //REVISIT: Should this take RECOVER into account? 
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }
     
     public int getMinimumSize() {
         return getNestedExpansion().getMinimumSize();
     }

     public int getMaximumSize() {
         return getNestedExpansion().getMaximumSize();
     }
     
     public boolean isConcrete() {
           return getNestedExpansion().isConcrete();
     }

     public boolean getSpecifiesLexicalStateSwitch() {
         return getNestedExpansion().getSpecifiesLexicalStateSwitch();
     }
}

TokenTypeActivation :
  (
   "ACTIVATE_TOKENS" 
   |
   "DEACTIVATE_TOKENS" {CURRENT_NODE.setDeactivate(true);}
  )
  "(" <IDENTIFIER> ("," <IDENTIFIER>)* ")"
;

INJECT TokenTypeActivation :
  import java.util.ArrayList;
  import java.util.List;
  import com.javacc.core.TokenSet;
  extends com.javacc.core.Expansion
{
   @Property public boolean deactivate;
   public List<String> getTokenNames() {
       List<String> result = new ArrayList<>();
       for (Identifier id : childrenOfType(Identifier.class)) result.add(id.getImage());
       return result;
   }
   public boolean isConcrete() {return true;}

   public int getMaximumSize() {return 0;}

   public int getMinimumSize() {return 0;}

   public boolean isPossiblyEmpty() {return true;}
    
   public TokenSet getFirstSet() {return new TokenSet(getGrammar());}

   public TokenSet getFinalSet() {return new TokenSet(getGrammar());}

   public boolean isAlwaysSuccessful() {return false;}

   public boolean getSpecifiesLexicalStateSwitch() {return false;}
}

Failure# : 
   {
       String message = null;
   }
   "FAIL"
   [
      <STRING_LITERAL> {message = ((StringLiteral)lastConsumedToken).getString();}
      |
      Block
   ]
   {
       CURRENT_NODE.setMessage("Failure: " + message);
   }
;



INJECT Failure :
   import com.javacc.core.TokenSet;
   extends com.javacc.core.Expansion
{
    @Property String message;
    public CodeBlock getCode() {
        return firstChildOfType(CodeBlock.class);
    }

    public boolean isConcrete() {return true;}
    
    public int getMaximumSize() {return 0;}

    public int getMinimumSize() {return 0;}

    public boolean isPossiblyEmpty() {return true;}
    
    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}

    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}

    public boolean isAlwaysSuccessful() {return false;}

    public boolean getSpecifiesLexicalStateSwitch() {return false;}
}

LexicalStateSwitch : "LEXICAL_STATE" <IDENTIFIER> ;

INJECT LexicalStateSwitch : {
   public String getLexicalStateName() {
       return firstChildOfType(Identifier.class).getImage();
   }
}

TryBlock : 
    "try" "{" ExpansionChoice "}"
    (
        CatchBlock
    )*
    [
        FinallyBlock
    ]
;

INJECT TryBlock  : 
    import java.util.List;
    import com.javacc.core.TokenSet;
    import com.javacc.core.Expansion;
    extends Expansion;
{
    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }
    
    public List<CatchBlock> getCatchBlocks() {
        return childrenOfType(CatchBlock.class);
    }

    public FinallyBlock getFinallyBlock() {
        return firstChildOfType(FinallyBlock.class);
    }
    
    public boolean isPossiblyEmpty() {
        return getNestedExpansion().isPossiblyEmpty();
    }
    
    public TokenSet getFirstSet() {
        return getNestedExpansion().getFirstSet();
    }
    
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }
     
    public int getMinimumSize() {
        return getNestedExpansion().getMinimumSize();
    }

    public int getMaximumSize() {
        return getNestedExpansion().getMaximumSize();
    }

    public boolean isConcrete() {
          return getNestedExpansion().isConcrete();
    }

    public boolean getSpecifiesLexicalStateSwitch() {
        return getNestedExpansion().getSpecifiesLexicalStateSwitch();
    }
}


INJECT CodeBlock :
   import com.javacc.core.TokenSet;
   extends com.javacc.core.Expansion;
{
    @Property boolean appliesInLookahead;

    public CodeBlock getJavaCode() {
        return this;
    }
    
    public boolean isPossiblyEmpty() {
       return true;
    }
    
    /**
     * These are here to fullfil the superclass contract. They are never used. 
     */

    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}

    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}
    
    public int getMinimumSize() {return 0;}

    public int getMaximumSize() {return 0;}
    
    public boolean isConcrete() {
        return true; //REVISIT.
    }

    public boolean getSpecifiesLexicalStateSwitch() {return false;}
}

RegexpExpansion(boolean noNfa) #void :
 (
  RegexpStringLiteral {((RegexpStringLiteral)peekNode()).setNoNfa(noNfa);}
  |
  SCAN {!noNfa} ~\.\TokenProduction =>
  (RegexpRef|EndOfFile)
  |
  SCAN 3 {!noNfa && (isInProduction("TokenProduction")||grammar.getUserDefinedLexer())} =>
  InPlaceRegexp 
 )
 [
      SCAN {isInProduction("BNFProduction") && !isInProduction("Lookahead")}
      =>
      {
          RegularExpression regexp = (RegularExpression) peekNode();
          regexp.setTolerantParsing(true);
      }
      "!" {regexp.addChild(popNode());}
 ]
;


InPlaceRegexp #void :
{
    RegularExpression re, choice;
    String image = "";
    Token t;
    boolean isPrivate= false;
}
  t=<LT>
  [
   (
     t=<IDENTIFIER> {image = t.getImage();}
     |
     SCAN ~\...\BNFProduction 
     => "#"t=<IDENTIFIER> {image = t.getImage(); isPrivate= true;}
   )
   ":"
  ]
  {clearNodeScope();}
  RegexpChoice {choice = (RegularExpression) peekNode();} 
  <GT>
  {
      if (choice instanceof RegexpRef) {
        RegexpSequence seq = new RegexpSequence();
        seq.addChild(choice);
        re = seq;
      } else {
        re = choice;
      }
      if (image.length() ==0 && isInProduction("BNFProduction")) {
         grammar.addError(t, "It is mandatory to label an inline regexp in a grammar production.");
      }
      re.setLabel(image);
      re.setGeneratedClassName(image);
      re.setPrivate(isPrivate); 
      re.setBeginLine(t.getBeginLine());
      re.setBeginColumn(t.getBeginColumn());
      pokeNode(re);
  }
;

RegexpStringLiteral# :
   <STRING_LITERAL>
   {
      String image = ((StringLiteral)lastConsumedToken).getString();
      CURRENT_NODE.setImage(image);
   }
;

INJECT RegexpStringLiteral : 
   import com.javacc.core.*;
   extends RegularExpression;
{
  @Property String image;
  @Property boolean noNfa;
  

  public String toString() {
    return super.toString() + " - " + getImage();
  }
  
  //REVISIT What about different lexical states? As well as ignoreCase... 
  public boolean equals(Object obj) {
      return obj instanceof RegexpStringLiteral && ((RegexpStringLiteral) obj).image == this.image;
  }
  
  public int hashCode() {
      return image.hashCode();
  }

  public boolean matchesEmptyString() {
      return getImage().length() == 0;
  }
}

RegexpRef RegexpRef : 
{
   Token t;
}
    "<"
    t=<IDENTIFIER> =>||
    ">" 
    {
       CURRENT_NODE.setLabel(t.getImage());
       return CURRENT_NODE;
    }
;

INJECT RegexpRef : 
    import com.javacc.core.*;
    extends RegularExpression;
{
    @Property RegularExpression regexp;

    public boolean isPrivate() {
        return regexp!= null && regexp.isPrivate(); //REVISIT, why do we need a null check?
    }

    public boolean matchesEmptyString() {
        return regexp != null && regexp.matchesEmptyString();
    }
}

EndOfFile : "<" <_EOF> =>|| ">" ;

INJECT EndOfFile : extends com.javacc.core.RegularExpression
{
    public boolean matchesEmptyString() {return true;}
}

RegexpChoice :
    RegexpSequence 
    ("|" RegexpSequence)*
;

RegexpChoiceInParen #RegexpChoice : 
   "(" RegexpSequence() ("|" RegexpSequence())* ")"
;

INJECT RegexpChoice : 
    import java.util.List;
    import com.javacc.core.RegularExpression;
    extends RegularExpression;
{
    public List<RegularExpression> getChoices() {
        return childrenOfType(RegularExpression.class);
    }

    public boolean matchesEmptyString() {
        for (RegularExpression choice: getChoices()) {
            if (choice.matchesEmptyString()) {
                return true;
            }
        }
        return false;
    }
}

RegexpSequence :
   (
      RegexpStringLiteral
      |
      RegexpRef
      |
      CharacterList
      |
      RepeatedRegexp
   )+
;

INJECT RegexpSequence : 
   import java.util.*;
   import com.javacc.core.RegularExpression;
   extends RegularExpression;
{
   public List<RegularExpression> getUnits() {
       return childrenOfType(RegularExpression.class);
   }

   public boolean matchesEmptyString() {
       for (RegularExpression child : getUnits()) {
           if (!child.matchesEmptyString()) return false;
       }
       return true;
   }
}

RepeatedRegexp #void : 
{
     int r1 = 0, r2 = -1;
     Token t;
     boolean hasMax = false;
}
  RegexpChoiceInParen
  (  "+" #OneOrMoreRegexp(2) 
   | "*" #ZeroOrMoreRegexp(2)
   | "?" #ZeroOrOneRegexp(2) 
   | "{" t  = <INTEGER_LITERAL> {r1 = ((IntegerLiteral)t).getValue();}
         [ "," { hasMax = true; } [ t = <INTEGER_LITERAL> {r2=((IntegerLiteral)t).getValue();} ] ]
     "}" #RepetitionRange(4 + (hasMax ? 1 : 0) + (r2!=-1 ? 1 : 0))
     {
         RepetitionRange range = (RepetitionRange) peekNode();
         range.setMin(r1);
         range.setMax(r2);
     }
  )?
;

INJECT RepetitionRange : 
   import com.javacc.core.RegularExpression;
   extends RegularExpression;
{
    @Property int min = 0, max = -1;


    public boolean hasMax() {
        return firstChildOfType(COMMA) != null;
    }
    
    public RegularExpression getRegexp() { 
        return firstChildOfType(RegularExpression.class);
    }

    public boolean matchesEmptyString() {
        return min==0 || getRegexp().matchesEmptyString();
    }
}

INJECT OneOrMoreRegexp : 
   import com.javacc.core.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }

   public boolean matchesEmptyString() {
       return getRegexp().matchesEmptyString(); 
   }
}

INJECT ZeroOrMoreRegexp : 
   import com.javacc.core.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }
   
   public void setRegexp(RegularExpression regexp) {
      RegularExpression current = getRegexp();
      if (current != null) {
          replaceChild(current, regexp);
      } else {
          addChild(0, regexp);
      }
   }

   public boolean matchesEmptyString() {
       return true;
   }
}

INJECT ZeroOrOneRegexp : 
   import com.javacc.core.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }
   
   public void setRegexp(RegularExpression regexp) {
      RegularExpression current = getRegexp();
      if (current != null) {
          addChild(indexOf(current), regexp);
          removeChild(current);
      } else {
          addChild(0, regexp);
      }
   }

   public boolean matchesEmptyString() {
       return true;
   }
}

CharacterList :
  ["~"]
  "[" [CharacterRange
        ( "," CharacterRange)*
      ]
  "]"
;

INJECT CharacterList : 
   import java.util.*;
   import com.javacc.core.*;
   extends RegularExpression;
{
    public List<CharacterRange> getDescriptors() {
        return childrenOfType(CharacterRange.class);
    }

    public boolean isNegated() {
        return firstChildOfType(TokenType.TILDE) != null;
    }

    public boolean matchesEmptyString() {
            return false;
        }
    }

CharacterRange# :
    <STRING_LITERAL>
    [ 
    "-"
    <STRING_LITERAL>
   ]
;

INJECT CharacterRange :
{
    public int left, right;
    
    public CharacterRange() {} 
    
    public CharacterRange(int left, int right) {
        setRange(left, right);
    }
    
    public void setRange(int left, int right) {
        if (left > right) {
            throw new ArrayIndexOutOfBoundsException();
        }
        this.left = left;
        this.right = right;
    }

    public boolean isSingleChar() {
       return left == right;
    }

    static private boolean isSingleChar(String s) {
       if (s.length() == 1) return true;
       if (s.length() == 2) {
           return Character.isSurrogatePair(s.charAt(0), s.charAt(1));
       }
       return false;
    }

    public void close() {
        java.util.List<StringLiteral> bounds = childrenOfType(StringLiteral.class);
        String left = bounds.get(0).getString();
        if (!isSingleChar(left)) {
            getGrammar().addError(bounds.get(0),
                    "String in character list may contain only one character.");
        }
        this.left = this.right = left.codePointAt(0);
        if (bounds.size()>1) {
            String right = bounds.get(1).getString();
            if (!isSingleChar(right)) {
                getGrammar().addError(bounds.get(1),
                        "String in character list may contain only one character.");
            }
            this.right = right.codePointAt(0);
        }
        if (this.left>this.right) {
            getGrammar().addError(this, "The left side of the character range must a lower ordinal (in Unicode) value than the right side.");
        }
    }
}

