[#ftl strict_vars=true]
[#--
 Copyright (C) 2021 Vinay Sajip, vinay_sajip@yahoo.co.uk
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

     * Redistributions of source code must retain the above copyright
       notices, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in
       the documentation and/or other materials provided with the
       distribution.
     * Neither the name Vinay Sajip nor the names of any contributors
       may be used to endorse or promote products derived from this
       software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE POSSIBILITY OF SUCH DAMAGE.
 --]
# Parser utils package. Generated by ${generated_by}. Do not edit.
from math import ceil
import re

__all__ = [
    # used in lexer
    'BitSet',
    'FileLineMap',
    'as_chr',
    'cached_property',
    # used in tokens
    'get_file_line_map_by_name',
    # used in parser
    'EMPTY_SET',
    'ListIterator',
    'StringBuilder',
    '_Set',
    '_List'
]

CODING_PATTERN = re.compile(rb'^[ \t\f]*#.*coding[:=][ \t]*([-_.a-zA-Z0-9]+)')

EMPTY_SET = frozenset()


def as_chr(o):
    if isinstance(o, int):
        return chr(o)
    return o


# Copied from distlib. Could be imported from Bottle but that will pull in SSL
# and interfere with gevent monkey-patching
class cached_property(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, obj, cls=None):
        if obj is None:
            return self
        value = self.func(obj)
        object.__setattr__(obj, self.func.__name__, value)
        return value


INT_BITSIZE = 64
BIT_MASK = (1 << 64) - 1
ALL_SET = (1 << INT_BITSIZE) - 1
ALL_CLEAR = 0

BIT_POS = {}
for i in range(INT_BITSIZE):
    BIT_POS[1 << i] = i

def _ints_needed(bits):
    return int(ceil(bits / INT_BITSIZE))

[#var optimize_bitset = true]
[#var cache_empty = true]
[#var toggle_needed = false]
class BitSet:

    __slots__ = ('bits', 'ints', 'max_pos'[#if cache_empty], '_empty'[/#if])

    def __init__(self, bits=None):
        self.bits = bits
        self.ints = []
[#if cache_empty]
        self._empty = True
[/#if]
        self.max_pos = 0  # highest value accessed for when bits is None
        if bits is not None:
            self.ints = [ALL_CLEAR for i in range(_ints_needed(bits))]
            self.max_pos = bits - 1

[#if !optimize_bitset]
    def _check_pos(self, pos):
        if pos < 0:
            raise ValueError(f'bit position {pos} cannot be negative')
        if self.bits is None:
            idx = _ints_needed(pos + 1)
            n = len(self.ints)
            if idx > n:
                self.ints.extend([ALL_CLEAR] * (idx - n))
            self.max_pos = max(self.max_pos, pos)
        elif pos > self.bits:
            raise ValueError(f'bit position {pos} exceeds BitSet capacity of {self.bits}')

    def _idx_and_bit(self, pos):
        self._check_pos(pos)
        return divmod(pos, INT_BITSIZE)

[/#if]
    def set(self, pos=-1, value=1):
        if pos == -1:
            value = ALL_SET if value == 1 else ALL_CLEAR
            for i in range(len(self.ints)):
                self.ints[i] = value
        else:
[#if optimize_bitset]
            idx, bit = divmod(pos, INT_BITSIZE)
[#else]
            idx, bit = self._idx_and_bit(pos)
[/#if]
            if value:
                self.ints[idx] |= (1 << bit)
            else:
                self.ints[idx] &= ~(1 << bit)
[#if cache_empty]
        # If None, we need to recompute _empty
        self._empty = False if value else None
[/#if]

    def clear(self, pos=-1, upto=-1):
        if upto == -1:
            self.set(pos, value=0)
        else:
            assert pos >= 0 and pos < upto
[#if optimize_bitset]
            idx1, bit1 = divmod(pos, INT_BITSIZE)
            idx2, bit2 = divmod(upto - 1, INT_BITSIZE)
[#else]
            idx1, bit1 = self._idx_and_bit(pos)
            idx2, bit2 = self._idx_and_bit(upto - 1)
[/#if]
            if idx1 == idx2 and bit1 == bit2:
                # just 1 bit to do
                mask1 = 1 << bit1
                self.ints[idx1] &= ~mask1
            elif idx1 == idx2:
                # just one int to do
                mask1 = (1 << bit1) - 1
                mask2 = ((~((1 << bit2) - 1)) << 1) & BIT_MASK
                self.ints[idx1] &= (mask1 | mask2)
            else:
                mask1 = (1 << bit1) - 1
                mask2 = ((~((1 << bit2) - 1)) << 1) & BIT_MASK
                self.ints[idx1] &= mask1
                self.ints[idx2] &= mask2
                # any in between first and last get zeroed
                idx1 += 1
                while idx1 < idx2:
                    self.ints[idx1] = 0
                    idx1 += 1
[#if cache_empty]
        self._empty = None
[/#if]

[#if toggle_needed]
    def _flip_all(self):
        for i in range(len(self.ints)):
            self.ints[i] ^= ALL_SET
[#if cache_empty]
        # If None, we need to recompute _empty
        self._empty = None
[/#if]

    def toggle(self, pos=-1):
        if pos == -1:
            self._flip_all()
        else:
[#if optimize_bitset]
            idx, bit = divmod(pos, INT_BITSIZE)
[#else]
            idx, bit = self._idx_and_bit(pos)
[/#if]
            self.ints[idx] ^= (1 << bit)
[#if cache_empty]
            # If None, we need to recompute _empty
            self._empty = None
[/#if]

[/#if]
    def __getitem__(self, pos):
[#if optimize_bitset]
        idx, bit = divmod(pos, INT_BITSIZE)
[#else]
        idx, bit = self._idx_and_bit(pos)
[/#if]
        return int(self.ints[idx] & (1 << bit) > 0)

[#if !cache_empty]
    @property
    def is_empty(self):
        last = len(self.ints) - 1
        for i, v in enumerate(self.ints):
            if i < last:
                if v != ALL_CLEAR:
                    return False
            else:
                # last int needs special handling. Only check bits
                # below max_pos
                idx, bit = divmod(self.max_pos + 1, INT_BITSIZE)
                if idx == i:
                    mask = (1 << bit) - 1
                    if v & mask != ALL_CLEAR:
                        return False
                else:
                    # this is reached self.max_pos represents the last
                    # bit (most significant) of the last int
                    if v != ALL_CLEAR:
                        return False
        return True
[#else]
    def _compute_empty(self):
        last = len(self.ints) - 1
        for i, v in enumerate(self.ints):
            if i < last:
                if v != ALL_CLEAR:
                    return False
            else:
                # last int needs special handling. Only check bits
                # below max_pos
                idx, bit = divmod(self.max_pos + 1, INT_BITSIZE)
                if idx == i:
                    mask = (1 << bit) - 1
                    if v & mask != ALL_CLEAR:
                        return False
                else:
                    # this is reached self.max_pos represents the last
                    # bit (most significant) of the last int
                    if v != ALL_CLEAR:
                        return False
        return True

    @property
    def is_empty(self):
        if self._empty is None:
            self._empty = self._compute_empty()
        return self._empty
[/#if]

[#if !optimize_bitset]
    @property
    def count(self):
        result = 0

        def count_bits(n):
            c = 0
            while n:
                n &= n - 1
                c += 1
            return c

        last = len(self.ints) - 1
        for i, v in enumerate(self.ints):
            if i < last:
                result += count_bits(v)
            else:
                # last int needs special handling. Only check bits
                # below max_pos
                idx, bit = divmod(self.max_pos + 1, INT_BITSIZE)
                if idx == i:
                    mask = (1 << bit) - 1
                    result += count_bits(v & mask)
                else:
                    # this is reached self.max_pos represents the last
                    # bit (most significant) of the last int
                    result += count_bits(v)
        return result

[/#if]
    def slow_next_set_bit(self, pos):
        for i in range(pos, self.max_pos + 1):
            if self[i]:
                return i
        return -1

    def fast_next_set_bit(self, pos):
        if pos < 0 or pos > self.max_pos:
            return -1
[#if optimize_bitset]
        idx, bit = divmod(pos, INT_BITSIZE)
[#else]
        idx, bit = self._idx_and_bit(pos)
[/#if]
        mask = 1 << bit
        if self.ints[idx] & mask:
            return pos
        while True:
            v = self.ints[idx] & ~(mask - 1)  # mask off lower bits
            if v == 0:
                idx += 1
                if idx >= len(self.ints):
                    return -1
                bit = 0
                mask = 1
                continue
            # v & -v leaves only the least significant bit
            result = INT_BITSIZE * idx + BIT_POS[v & -v]
            return result

[#if optimize_bitset]
    next_set_bit = fast_next_set_bit
[#else]
    next_set_bit = slow_next_set_bit
[/#if]

    def previous_set_bit(self, pos):
        if pos < 0:
            return -1
        idx, bit = divmod(pos, INT_BITSIZE)
        mask = 1 << bit
        if self.ints[idx] & mask:
            return pos

        mask = 0 if bit == (INT_BITSIZE - 1) else ~((mask << 1) - 1)
        while True:
            v = self.ints[idx] & ~mask  # mask off higher bits
            if v == 0:
                idx -= 1
                if idx < 0:
                    return -1
                mask = 0
                continue
            result = 0
            v = v >> 1
            while v:
                result += 1
                v = v >> 1
            return result + INT_BITSIZE * idx


# A mapping of filenames to line maps

[#var TABS_TO_SPACES = 0, PRESERVE_LINE_ENDINGS="True", JAVA_UNICODE_ESCAPE="False", ENSURE_FINAL_EOL = grammar.ensureFinalEOL?string("True", "False")]
[#if grammar.settings.TABS_TO_SPACES??]
   [#set TABS_TO_SPACES = grammar.settings.TABS_TO_SPACES]
[/#if]
[#if grammar.settings.PRESERVE_LINE_ENDINGS?? && !grammar.settings.PRESERVE_LINE_ENDINGS]
   [#set PRESERVE_LINE_ENDINGS = "False"]
[/#if]
[#if grammar.settings.JAVA_UNICODE_ESCAPE?? && grammar.settings.JAVA_UNICODE_ESCAPE]
   [#set JAVA_UNICODE_ESCAPE = "True"]
[/#if]

FILE_LINE_MAPS = {}

def get_file_line_map_by_name(name):
    return FILE_LINE_MAPS[name]

class FileLineMap:

    __slots__ = (
        '_input_source',
        'line_offsets',
        'content',
        'buffer_position',
        'token_begin_line',
        'token_begin_column',
        'starting_line',
        'starting_column',
        'line',
        'column',
        'parsed_lines',
    )

    def __init__(self, input_source, stream_or_content, line, column):
        # Munged content, possibly replace unicode escapes, tabs, or
        # CRLF with LF.
        # Typically a filename, I suppose.
        self.input_source = input_source
        if stream_or_content is None:
            assert input_source, 'Neither an input source nor an input stream was specified'
            with open(input_source, 'rb') as f:
                stream_or_content = f.read()
            if len(stream_or_content) <= 3:
                encoding = 'utf-8'
            elif stream_or_content[:3] == b'\xEF\xBB\xBF':
                stream_or_content = stream_or_content[3:]
                encoding = 'utf-8'
            elif stream_or_content[:2] == b'\xFF\xFE':
                stream_or_content = stream_or_content[2:]
                encoding = 'utf-16le'
            elif stream_or_content[:2] == b'\xFE\xFF':
                stream_or_content = stream_or_content[2:]
                encoding = 'utf-16be'
            elif stream_or_content[:4] == b'\xFF\xFE\x00\x00':
                stream_or_content = stream_or_content[4:]
                encoding = 'utf-32le'
            elif stream_or_content[:4] == b'\x00\x00\xFE\xFF':
                stream_or_content = stream_or_content[4:]
                encoding = 'utf-32be'
            else:
                # No encoding from BOM.
                encoding = 'utf-8'
                if input_source and input_source.endswith(('.py', '.pyw')):
                    # Look for coding in first two lines
                    parts = stream_or_content.split(b'\n', 2)
                    m = CODING_PATTERN.match(parts[0])
                    if not m and len(parts) > 1:
                        m = CODING_PATTERN.match(parts[1])
                    if m:
                        encoding = m.groups()[0].decode('ascii')
            stream_or_content = stream_or_content.decode(encoding)
        elif hasattr(stream_or_content, 'read'):
            stream_or_content = stream_or_content.read()
        self.content = self.munge_content(stream_or_content, ${TABS_TO_SPACES}, ${PRESERVE_LINE_ENDINGS}, ${JAVA_UNICODE_ESCAPE}, ${ENSURE_FINAL_EOL})
        # A list of offsets of the beginning of lines
        self.line_offsets = self.create_line_offsets_table(self.content)
        self.set_start_position(line, column)
        self.buffer_position = 0
        self.token_begin_line = 0
        self.token_begin_column = 0
        # If this is set, it determines which lines in the file are
        # actually processed.
        self.parsed_lines = None  # a BitSet

    @property
    def input_source(self):
        return self._input_source

    @input_source.setter
    def input_source(self, value):
        FILE_LINE_MAPS[value] = self
        self._input_source = value

    def is_parsed_line(self, lineno):
        return (self.parsed_lines is None) or self.parsed_lines.get(1 + lineno - self.starting_line)

    def set_start_position(self, line, column):
        self.starting_line = line
        self.starting_column = column
        self.line = line
        self.column = column

    def munge_content(self, content, tabs_to_spaces, preserve_lines,
                      java_unicode_escape, ensure_final_endline):
        if tabs_to_spaces <= 0 and preserve_lines and not java_unicode_escape:
            if ensure_final_endline:
                last_char = content[-1]
                if last_char != '\n' and last_char != '\r':
                    content += '\n'
            return content

        buf = []
        index = 0
        # This is just to handle tabs to spaces. If you don't have that setting set, it
        # is really unused.
        col = 0
        just_saw_unicode_escape = False
        # Don't know if this is really needed for Python ...
        code_points = list(content)
        cplen = len(code_points)
        while index < cplen:
            ch = code_points[index]
            index += 1
            if ch == '\\' and java_unicode_escape and index < cplen:
                ch = code_points[index]
                index += 1
                if ch != 'u':
                    just_saw_unicode_escape = False
                    buf.append('\\')
                    buf.append(ch)
                    if ch == '\n':
                        col = 0
                    else:
                        col += 2
                else:
                    while code_points[index] == 'u':
                        index += 1
                        # col += 1
                    hex_buf = []
                    for i in range(4):
                        hex_buf.append(code_points[index])
                        index += 1
                    current = int(''.join(hex_buf), 16)
                    last = buf[-1] if len(buf) > 0 else ''
                    # shouldn't see surrogate pairs, normally
                    buf.append(chr(current))
                    just_saw_unicode_escape = True
                    # col += 6
                    col += 1
                    # We're not going to be trying to track line/column information relative to the original content
                    # with tabs or unicode escape, so we just increment 1, not 6
            elif ch == '\r' and not preserve_lines:
                just_saw_unicode_escape = False
                buf.append('\n')
                if index < cplen:
                    ch = code_points[index]
                    index += 1
                    if ch != '\n':
                        buf.append(ch)
                        col += 1
                    else:
                        col = 0
            elif ch == '\t' and tabs_to_spaces > 0:
                just_saw_unicode_escape = False
                spaces_to_add = tabs_to_spaces - col % tabs_to_spaces
                for i in range(spaces_to_add):
                    buf.append(' ')
                    col += 1
            else:
                just_saw_unicode_escape = False
                buf.append(ch)
                if ch == '\n':
                    col = 0
                else:
                    col += 1
        if ensure_final_endline:
            last_char = buf[-1] if len(buf) > 0 else ''
            if last_char != '\n' and last_char!='\r':
                buf.append('\n')
        return ''.join(buf)

    def create_line_offsets_table(self, content):
        if not content:
            return [0]
        length = len(content)
        line_count = content.count('\n')
        if content[-1] != '\n':
            line_count += 1
        result = [0]
        for i in range(length):
            ch = content[i]
            if ch == '\n':
                if (i + 1) == length:
                    break
                result.append(i + 1)
        return result

    def get_line(self):
        if not self.is_parsed_line(self.line):
            self.advance_line()
        return self.line

    def get_column(self):
        return self.column

    @property
    def end_line(self):
        if self.column == 1 and self.line > self.token_begin_line:
            return self.line - 1
        return self.line

    @property
    def end_column(self):
        if self.column == 1:
            if self.line == self.token_begin_line:
                return 1
            return self.get_line_length(self.line - 1)
        return self.column - 1

    def go_to(self, line, column):
        self.buffer_position = self.get_offset(line, column)
        self.line = line
        self.column = column

    def backup(self, amount):
        for i in range(amount):
            if self.column == 1:
                self.backup_line()
            else:
                self.column -= 1
                self.buffer_position -= 1

    def forward(self, amount):
        for i in range(amount):
            if self.column < self.get_line_length(self.line):
                self.buffer_position += 1
                self.column += 1
            else:
                self.advance_line()

    def advance_line(self):
        line = self.line + 1
        while not self.is_parsed_line(line) and line - self.starting_line < len(self.line_offsets):
            line += 1
        self.line = line
        if line - self.starting_line >= len(self.line_offsets):
            self.buffer_position = len(self.content)
        else:
            self.buffer_position = self.get_line_start_offset(line)
        self.column = 1

    def backup_line(self):
        line = self.line - 1
        while not self.is_parsed_line(line) and line >= self.starting_line:
            line -= 1
        self.line = line
        if line < self.starting_line:
            self.go_to(self.starting_line, self.starting_column)
        else:
            self.column = self.get_line_length(line)
            self.buffer_position = self.get_line_start_offset(line) + self.column - 1

    def read_char(self):
        if self.buffer_position >= len(self.content):
            return ''
        ch = self.content[self.buffer_position]
        self.buffer_position += 1
        if ch != '\n':
            self.column += 1
        else:
            self.advance_line()
        return ch

    def get_line_length(self, lineno):
        start_offset = self.get_line_start_offset(lineno)
        end_offset = self.get_line_end_offset(lineno)
        return 1 + end_offset - start_offset

    def get_line_start_offset(self, lineno):
        real_line_number = lineno - self.starting_line
        if real_line_number <= 0:
            return 0
        if real_line_number >= len(self.line_offsets):
            return len(self.content)
        return self.line_offsets[real_line_number]

    def get_line_end_offset(self, lineno):
        real_line_number = lineno - self.starting_line
        if real_line_number < 0:
            return 0
        if real_line_number >= len(self.line_offsets):
            return len(self.content)
        if real_line_number == len(self.line_offsets) - 1:
            return len(self.content) - 1
        return self.line_offsets[real_line_number + 1] - 1

    def get_offset(self, line, column):
        if line == 0:
            line = self.starting_line  # REVISIT? This should not be necessary!
        column_adjustment = self.starting_column if line == self.starting_line else 1
        return self.line_offsets[line - self.starting_line] + column - column_adjustment

    def get_source_line(self, lineno):
        start = self.get_line_start_offset(lineno)
        end = self.get_line_end_offset(lineno)
        return self.content[start:end]

    def __repr__(self):
        return '<%s cur=(%d, %d) sta=(%d, %d) end=(%d, %d)>' % (
                type(self).__name__, self.line, self.column,
                self.starting_line, self.starting_column,
                self.end_line, self.end_column)

class ListIterator:
#
# Emulation of the Java interface / implementation
#
    __slots__ = (
        'elems',
        'num',
        'pos'
    )

    def __init__(self, alist, pos=0):
        self.elems = list(alist)
        self.num = len(alist)
        assert pos <= self.num
        self.pos = pos

    @property
    def has_next(self):
        return self.pos < self.num

    @property
    def has_previous(self):
        return self.pos > 0

    @property
    def next(self):
        assert self.has_next
        result = self.elems[self.pos]
        if self.pos < self.num:
            self.pos += 1
        return result

    @property
    def previous(self):
        assert self.has_previous
        result = self.elems[self.pos - 1]
        if self.pos > 0:
            self.pos -= 1
        return result

class StringBuilder:
    """
    Adapter class for Java StringBuilder
    """
    __slots__ = ('buf',)

    def __init__(self):
        self.buf = []

    def append(self, value):
        self.buf.append(str(value))

    def __str__(self):
        return ''.join(self.buf)

class _Set(set):
    """
    Adapter class for Java.util.HashSet
    """
    def remove(self, item):
        if item in self:
            super().remove(item)

class _List(list):
    """
    Adapter class for Java.util.List
    """
    def __init__(self, *args):
        super().__init__()
        if args:
            arg0 = args[0]
            if isinstance(arg0, list):
                self.extend(arg0)

    def add(self, item):
        self.append(item)

    def index_of(self, item):
        try:
            return self.index(item)
        except ValueError:
            return -1

    def size(self):
        return len(self)

    def remove(self, idx):
        del self[idx]

    def add_all(self, other):
        self.extend(other)

_FROZEN_SETS = {}

def make_frozenset(*types):
    if types in _FROZEN_SETS:
        result = _FROZEN_SETS[types]
    else:
        result = frozenset(types)
        _FROZEN_SETS[types] = result
    return result

class _GenWrapper(object):
    """
    Adapter class for Python generators to Java iterators
    """
    def __init__(self, gen):
        self.gen = gen
        self._step()

    def _step(self):
        try:
            self.next_value = next(self.gen)
            self._has_next = True
        except StopIteration:
            self._has_next = False

    def has_next(self):
        return self._has_next

    def next(self):
        assert self._has_next
        rv = self.next_value
        self._step()
        return rv
