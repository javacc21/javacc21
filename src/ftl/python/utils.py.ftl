[#ftl strict_vars=true]
# Copyright (C) 2021 Vinay Sajip, vinay_sajip@yahoo.co.uk
# Parser utils package. Generated by ${generated_by}. Do not edit.
from math import ceil

__all__ = [
    # used in lexer
    'BitSet',
    'FileLineMap',
    'as_chr',
    # used in tokens
    'get_file_line_map_by_name',
    # used in parser
    'EMPTY_SET',
    'ListIterator',
    'StringBuilder',
    'Set',
    'List'
]

EMPTY_SET = frozenset()

INT_BITSIZE = 32
ALL_SET = (1 << INT_BITSIZE) - 1
ALL_CLEAR = 0

def as_chr(o):
    if isinstance(o, int):
        return chr(o)
    return o

def _ints_needed(bits):
    return int(ceil(bits / INT_BITSIZE))

class BitSet:

    def __init__(self, bits=None):
        self.bits = bits
        self.ints = []
        self.max_pos = 0  # highest value accessed for when bits is None
        if bits is not None:
            self.ints = [ALL_CLEAR for i in range(_ints_needed(bits))]
            self.max_pos = bits - 1

    def _check_pos(self, pos):
        if pos < 0:
            raise ValueError(f'bit position {pos} cannot be negative')
        if self.bits is None:
            idx = _ints_needed(pos + 1)
            n = len(self.ints)
            if idx > n:
                self.ints.extend([ALL_CLEAR] * (idx - n))
            self.max_pos = max(self.max_pos, pos)
        elif pos > self.bits:
            raise ValueError(f'bit position {pos} exceeds BitSet capacity of {self.bits}')

    def _idx_and_bit(self, pos):
        self._check_pos(pos)
        return divmod(pos, INT_BITSIZE)

    def set(self, pos=-1, value=1):
        if pos == -1:
            value = ALL_SET if value == 1 else ALL_CLEAR
            for i in range(len(self.ints)):
                self.ints[i] = value
        else:
            idx, bit = self._idx_and_bit(pos)
            if value:
                self.ints[idx] |= (1 << bit)
            else:
                self.ints[idx] &= ~(1 << bit)

    def clear(self, pos=-1):
        self.set(pos, value=0)

    def _flip_all(self):
        for i in range(len(self.ints)):
            self.ints[i] ^= ALL_SET

    def toggle(self, pos=-1):
        if pos == -1:
            self._flip_all()
        else:
            idx, bit = self._idx_and_bit(pos)
            self.ints[idx] ^= (1 << bit)

    def __getitem__(self, position):
        idx, bit = self._idx_and_bit(position)
        return int(self.ints[idx] & (1 << bit) > 0)

    @property
    def is_empty(self):
        last = len(self.ints) - 1
        for i, v in enumerate(self.ints):
            if i < last:
                if v != ALL_CLEAR:
                    return False
            else:
                # last int needs special handling. Only check bits
                # below max_pos
                idx, bit = divmod(self.max_pos + 1, INT_BITSIZE)
                if idx == i:
                    mask = (1 << bit) - 1
                    if v & mask != ALL_CLEAR:
                        return False
                else:
                    # this is reached self.max_pos represents the last
                    # bit (most significant) of the last int
                    if v != ALL_CLEAR:
                        return False
        return True

    @property
    def count(self):
        result = 0

        def count_bits(n):
            c = 0
            while n:
                n &= n - 1
                c += 1
            return c

        last = len(self.ints) - 1
        for i, v in enumerate(self.ints):
            if i < last:
                result += count_bits(v)
            else:
                # last int needs special handling. Only check bits
                # below max_pos
                idx, bit = divmod(self.max_pos + 1, INT_BITSIZE)
                if idx == i:
                    mask = (1 << bit) - 1
                    result += count_bits(v & mask)
                else:
                    # this is reached self.max_pos represents the last
                    # bit (most significant) of the last int
                    result += count_bits(v)
        return result

    def next_set_bit(self, pos):
        result = -1
        for i in range(pos, self.max_pos + 1):
            if self[i]:
                result = i
                break
        return result

# A mapping of filenames to line maps

[#var TABS_TO_SPACES = 0, PRESERVE_LINE_ENDINGS="True", JAVA_UNICODE_ESCAPE="False", ENSURE_FINAL_EOL = grammar.ensureFinalEOL?string("True", "False")]
[#if grammar.settings.TABS_TO_SPACES??]
   [#set TABS_TO_SPACES = grammar.settings.TABS_TO_SPACES]
[/#if]
[#if grammar.settings.PRESERVE_LINE_ENDINGS?? && !grammar.settings.PRESERVE_LINE_ENDINGS]
   [#set PRESERVE_LINE_ENDINGS = "False"]
[/#if]
[#if grammar.settings.JAVA_UNICODE_ESCAPE?? && grammar.settings.JAVA_UNICODE_ESCAPE]
   [#set JAVA_UNICODE_ESCAPE = "True"]
[/#if]

FILE_LINE_MAPS = {}

def get_file_line_map_by_name(name):
    return FILE_LINE_MAPS[name]

class FileLineMap:

    def __init__(self, input_source, stream_or_content, line, column):
        # Munged content, possibly replace unicode escapes, tabs, or
        # CRLF with LF.
        # Typically a filename, I suppose.
        self.input_source = input_source
        if hasattr(stream_or_content, 'read'):
            stream_or_content = stream_or_content.read()
        self.content = self.munge_content(stream_or_content, ${TABS_TO_SPACES}, ${PRESERVE_LINE_ENDINGS}, ${JAVA_UNICODE_ESCAPE}, ${ENSURE_FINAL_EOL})
        # A list of offsets of the beginning of lines
        self.line_offsets = self.create_line_offsets_table(self.content)
        self.set_start_position(line, column)
        self.buffer_position = 0
        self.token_begin_line = 0
        self.token_begin_column = 0
        # If this is set, it determines which lines in the file are
        # actually processed.
        self.parsed_lines = None  # a BitSet

    def is_parsed_line(self, lineno):
        return (self.parsed_lines is None) or self.parsed_lines.get(1 + lineno - self.starting_line)

    def set_start_position(self, line, column):
        self.starting_line = line
        self.starting_column = column
        self.line = line
        self.column = column

    def munge_content(self, content, tabs_to_spaces, preserve_lines,
                      java_unicode_escape, ensure_final_endline):
        if tabs_to_spaces <= 0 and preserve_lines and not java_unicode_escape:
            if ensure_final_endline:
                last_char = content[-1]
                if last_char != '\n' and last_char != '\r':
                    content += '\n'
            return content

        buf = []
        index = 0
        # This is just to handle tabs to spaces. If you don't have that setting set, it
        # is really unused.
        col = 0
        just_saw_unicode_escape = False
        # Don't know if this is really needed for Python ...
        code_points = list(content)
        cplen = len(code_points)
        while index < cplen:
            ch = code_points[index]
            index += 1
            if ch == '\\' and java_unicode_escape and index < cplen:
                ch = code_points[index]
                index += 1
                if ch != 'u':
                    just_saw_unicode_escape = False
                    buf.append('\\')
                    buf.append(ch)
                    if ch == '\n':
                        col = 0
                    else:
                        col += 2
                else:
                    while code_points[index] == 'u':
                        index += 1
                        # col += 1
                    hex_buf = []
                    for i in range(4):
                        hex_buf.append(code_points[index])
                        index += 1
                    current = int(''.join(hex_buf), 16)
                    last = buf[-1] if len(buf) > 0 else ''
                    # shouldn't see surrogate pairs, normally
                    buf.append(chr(current))
                    just_saw_unicode_escape = True
                    # col += 6
                    col += 1
                    # We're not going to be trying to track line/column information relative to the original content
                    # with tabs or unicode escape, so we just increment 1, not 6
            elif ch == '\r' and not preserve_lines:
                just_saw_unicode_escape = False
                buf.append('\n')
                if index < cplen:
                    ch = code_points[index]
                    index += 1
                    if ch != '\n':
                        buf.append(ch)
                        col += 1
                    else:
                        col = 0
            elif ch == '\t' and tabs_to_spaces > 0:
                just_saw_unicode_escape = False
                spaces_to_add = tabs_to_spaces - col % tabs_to_spaces
                for i in range(spaces_to_add):
                    buf.append(' ')
                    col += 1
            else:
                just_saw_unicode_escape = False
                buf.append(ch)
                if ch == '\n':
                    col = 0
                else:
                    col += 1
        if ensure_final_endline:
            last_char = buf[-1]
            if last_char != '\n' and last_char!='\r':
                buf.append('\n')
        return ''.join(buf)

    def create_line_offsets_table(self, content):
        if not content:
            return [0]
        lineCount = 0
        length = len(content)
        for i, ch in enumerate(content):
            if ch == '\n':
                lineCount += 1
        if content[-1] != '\n':
            lineCount += 1
        result = [0]
        for i in range(1, length):
            ch = content[i]
            if ch == '\n':
                if i + 1 == length:
                    break
                result.append(i + 1)
        return result

    def get_line(self):
        if not self.is_parsed_line(self.line):
            self.advance_line()
        return self.line

    def get_column(self):
        return self.column

    @property
    def end_line(self):
        if self.column == 1 and self.line > self.token_begin_line:
            return self.line - 1
        return self.line

    @property
    def end_column(self):
        if self.column == 1:
            if self.line == self.token_begin_line:
                return 1
            return self.get_line_length(self.line - 1)
        return self.column - 1

    def go_to(self, line, column):
        self.buffer_position = self.get_offset(line, column)
        self.line = line
        self.column = column

    def backup(self, amount):
        for i in range(amount):
            if self.column == 1:
                self.backup_line()
            else:
                self.column -= 1
                self.buffer_position -= 1

    def forward(self, amount):
        for i in range(amount):
            if self.column < self.get_line_length(self.line):
                self.buffer_position += 1
                self.column += 1
            else:
                self.advance_line()

    def advance_line(self):
        line = self.line + 1
        while not self.is_parsed_line(line) and line - self.starting_line < len(self.line_offsets):
            line += 1
        self.line = line
        if line - self.starting_line >= len(self.line_offsets):
            self.buffer_position = len(self.content)
        else:
            self.buffer_position = self.get_line_start_offset(line)
        self.column = 1

    def backup_line(self):
        line = self.line - 1
        while not self.is_parsed_line(line) and line >= self.starting_line:
            line -= 1
        self.line = line
        if line < self.starting_line:
            self.go_to(self.starting_line, self.starting_column)
        else:
            self.column = self.get_line_length(line)
            self.buffer_position = self.get_line_start_offset(line) + self.column -1

    def read_char(self):
        if self.buffer_position >= len(self.content):
            return ''
        ch = self.content[self.buffer_position]
        self.buffer_position += 1
        if ch == '\n':
            self.advance_line()
            self.column = 1
        else:
            self.column += 1
        return ch

    def get_line_length(self, lineno):
        start_offset = self.get_line_start_offset(lineno)
        end_offset = self.get_line_end_offset(lineno);
        return 1 + end_offset - start_offset

    def get_line_start_offset(self, lineno):
        real_line_number = lineno - self.starting_line
        if real_line_number <= 0:
            return 0
        if real_line_number >= len(self.line_offsets):
            return len(self.content)
        return self.line_offsets[real_line_number]

    def get_line_end_offset(self, lineno):
        real_line_number = lineno - self.starting_line
        if real_line_number < 0:
            return 0
        if real_line_number >= len(self.line_offsets):
            return len(self.content)
        if real_line_number == len(self.line_offsets) -1:
            return len(self.content) - 1
        return self.line_offsets[real_line_number + 1] - 1

    def get_offset(self, line, column):
        if line == 0:
            line = self.starting_line  # REVISIT? This should not be necessary!
        column_adjustment = self.starting_column if line == self.starting_line else 1
        return self.line_offsets[line - self.starting_line] + column - column_adjustment

class ListIterator:
#
# Emulation of the Java interface / implementation
#
    def __init__(self, alist, pos=0):
        self.elems = list(alist)
        self.num = len(alist)
        assert pos <= self.num
        self.pos = pos

    @property
    def has_next(self):
        return self.pos < self.num

    @property
    def has_previous(self):
        return self.pos > 0

    @property
    def next(self):
        assert self.has_next
        result = self.elems[self.pos]
        if self.pos < self.num:
            self.pos += 1
        return result

    @property
    def previous(self):
        assert self.has_previous
        result = self.elems[self.pos - 1]
        if self.pos > 0:
            self.pos -= 1
        return result

class StringBuilder:
    def __init__(self):
        self.buf = []

    def append(self, value):
        self.buf.append(str(value))

    def __str__(self):
        return ''.join(self.buf)

class Set(set):
    def remove(self, item):
        if item in self:
            super().remove(item)

class List(list):
    def add(self, item):
        self.append(item)
        
    def index_of(self, item):
        try:
            return self.index(item)
        except ValueError:
            return -1

    def size(self):
        return len(self)

    def remove(self, idx):
        del self[idx]

# Any stuff below is for debugging only ... to be deleted later
[#-- var cases = [
  "STRICTFP",
  "TokenType.STRICTFP",
  "!(getToken(1).getImage().equals(\"yield\")&&isInProduction(\"SwitchExpression\"))",
  "foo.toString()",
  "lhs.isAssignableTo()",
  "lhs.isMethodCall()||lhs.isConstructorInvocation()||lhs.isAllocation()",
  "isParserTolerant()||permissibleModifiers.contains(getToken(1).getType())",
  "currentLookaheadToken==null&&!((Expression)peekNode()).isAssignableTo()",
  "currentLookaheadToken!=null||((Expression)peekNode()).isAssignableTo()",
  "getToken(1).getType()!=TokenType._DEFAULT"
] ]
[#list cases as case]
# "${case}" -> ${grammar.utils.translateString(case)}
[/#list]
 --]
[#list grammar.utils.sortedNodeClassNames as cn]
# ${cn}
[/#list]
