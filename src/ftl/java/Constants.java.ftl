/* Generated by: ${generated_by}. Do not edit. ${filename} */
[#if grammar.parserPackage?has_content]
package ${grammar.parserPackage};
[/#if]

import java.io.IOException;
import java.io.Reader;
import java.nio.charset.Charset;

/**
 * Token literal values and constants.
 */

  public interface ${grammar.constantsClassName} {

  public enum TokenType {
     [#list grammar.lexerData.regularExpressions as regexp]
       ${regexp.label},
     [/#list]
     [#list grammar.extraTokenNames as extraToken]
       ${extraToken},
     [/#list]
     INVALID
  }
  
  /**
   * Lexical States
   */

  public enum LexicalState {
  [#list grammar.lexerData.lexicalStates as lexicalState]
     ${lexicalState.name},
  [/#list]
   }

  static String displayChar(int ch) {
    if (ch == '\'') return "\'\\'\'";
    if (ch == '\\') return "\'\\\\\'";
    if (ch == '\t') return "\'\\t\'";
    if (ch == '\r') return "\'\\r\'";
    if (ch == '\n') return "\'\\n\'";
    if (ch == '\f') return "\'\\f\'";
    if (ch == ' ') return "\' \'";
    if (ch < 128 && !Character.isWhitespace(ch) && !Character.isISOControl(ch)) return "\'" + (char) ch + "\'";
    if (ch < 10) return "" + ch;
    return "0x" + Integer.toHexString(ch);
}

 static String addEscapes(String str) {
      StringBuilder retval = new StringBuilder();
      for (int ch : str.codePoints().toArray()) {
        switch (ch) {
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if (Character.isISOControl(ch)) {
                 String s = "0000" + java.lang.Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.appendCodePoint(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

   

// Annoying kludge really...
  static public String readToEnd(Reader reader) {
    try {
        return readFully(reader);
    } catch (IOException ioe) {
        throw new RuntimeException(ioe);
    }
  }

  static final int BUF_SIZE = 0x10000;

  static public String readFully(Reader reader) throws IOException {
    char[] block = new char[BUF_SIZE];
    int charsRead = reader.read(block);
    if (charsRead < 0) {
        throw new IOException("No input");
    } else if (charsRead < BUF_SIZE) {
        char[] result = new char[charsRead];
        System.arraycopy(block, 0, result, 0, charsRead);
        reader.close();
        return new String(block, 0, charsRead);
    }
    StringBuilder buf = new StringBuilder();
    buf.append(block);
    do {
        charsRead = reader.read(block);
        if (charsRead > 0) {
            buf.append(block, 0, charsRead);
        }
    } while (charsRead == BUF_SIZE);
    reader.close();
    return buf.toString();
  }

  /**
    * Rather bloody-minded way of converting a byte array into a string
    * taking into account the initial byte order mark (used by Microsoft a lot seemingly)
    * See: https://docs.microsoft.com/es-es/globalization/encoding/byte-order-markc
    * @param bytes the raw byte array 
    * @return A String taking into account the encoding in the byte order mark (if it was present). If no
    * byte-order mark was present, it assumes the raw input is in UTF-8.
    */
  static public String stringFromBytes(byte[] bytes) {
    int arrayLength = bytes.length;
    int firstByte = arrayLength>0 ? Byte.toUnsignedInt(bytes[0]) : 1;
    int secondByte = arrayLength>1 ? Byte.toUnsignedInt(bytes[1]) : 1;
    int thirdByte = arrayLength >2 ? Byte.toUnsignedInt(bytes[2]) : 1;
    int fourthByte = arrayLength > 3 ? Byte.toUnsignedInt(bytes[3]) : 1;
    if (firstByte == 0xEF && secondByte == 0xBB && thirdByte == 0xBF) {
        return new String(bytes, 3, bytes.length-3, Charset.forName("UTF-8"));
    }
    if (firstByte == 0 && secondByte==0 && thirdByte == 0xFE && fourthByte == 0xFF) {
        return new String(bytes, 4, bytes.length-4, Charset.forName("UTF-32BE"));
    }
    if (firstByte == 0xFF && secondByte == 0xFE && thirdByte == 0 && fourthByte == 0) {
        return new String(bytes, 4, bytes.length-4, Charset.forName("UTF-32LE"));
    }
    if (firstByte == 0xFE && secondByte == 0xFF) {
        return new String(bytes, 2, bytes.length-2, Charset.forName("UTF-16BE"));
    }
    if (firstByte == 0xFF && secondByte == 0xFE) {
        return new String(bytes, 2, bytes.length-2, Charset.forName("UTF-16LE"));
    }
    return new String(bytes, Charset.forName("UTF-8"));
  }
}

